<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: C++ template workshop</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ template workshop </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md64"></a>
Introduction to templates - building a toolbox</h1>
<p>Templates are a very powerful tool for writing code in c++. They allow you to do just about everything a C macro would allow (and more!), but with type safety and namespace awareness. My goal in this workshop is to give my knowledge of c++ templates away so that others might benefit and significantly advance their understanding of c++.</p>
<p>Even if you never write a single template in production code (though you probably will), this knowledge is <em>extremely</em> useful for reading and understanding existing template code, including standard library code. I did not become an expert in the standard library until I learned templates, for the simple reason that the standard library uses them all over the place :D.</p>
<p>Be warned, this is <em>not</em> a templates basics course. This course will cover advanced templating, though the first couple of lessons will cover the basics. The intended audience for this course is <em>advanced c++ developers</em>.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
A note on course design</h2>
<p>I modeled this course after my favorite programming book <a href="https://www.webpages.uidaho.edu/~stevel/504/LearnPythonTheHardWay.pdf">Learn Python the Hard Way</a>. Said book is for very inexperienced students looking to learn the Python programming language. However, I was so impressed by how <em>successful</em> the book was at educating readers that I decided to steal his ideas :).</p>
<p>It's true the intended audience of this workshop is not c++ beginners. However, many (or all) will be beginners when it comes to c++ templating, which is a very niche skill :). Here's the opening paragraph from his book, which contains the core ideas I'm seeking to emulate:</p>
<blockquote class="doxtable">
<p>The Hard Way Is Easier</p>
<p>This simple book is meant to get you started in programming. The title says it’s the hard way to learn to write code; but it’s actually not. It’s only the “hard” way because it’s the way people used to teach things. With the help of this book, you will do the incredibly simple things that all programmers need to do to learn a language:</p>
<ol type="1">
<li>Go through each exercise.</li>
<li>Type in each sample exactly.</li>
<li>Make it run.</li>
</ol>
<p>That’s it. This will be very difficult at first, but stick with it. If you go through this book, and do each unit test for one or two hours a night, you will have a good foundation for moving onto another book. You might not really learn “programming” from this book, but you will learn the foundation skills you need to start learning the language. This book’s job is to teach you the three most essential skills that a beginning programmer needs to know: Reading and Writing, Attention to Detail, Spotting Differences. </p>
</blockquote>
<p>It should be noted the "exercises" in this workshop are <code>c++</code> unit tests written using <a href="https://google.github.io/googletest/primer.html">googletest</a>.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
What is expected of participants</h2>
<p>Each participant will be expected to get a series of unit tests passing on a (remote) branch. The <code>main</code> branch of this code repository contains <em>the complete working algorithm code and implemented unit tests</em>. There is a secondary branch named <code>student</code> with much of the algorithm and unit test code either absent or commented out, create your branch from that branch. Example: </p><div class="fragment"><div class="line">git clone --recurse-submodules git@github.com:durandaltheta/cpp_template_workshop.git &amp;&amp; git checkout student &amp;&amp; git checkout -b your_branch_name &amp;&amp; git push --set-upstream origin your_branch_name</div>
</div><!-- fragment --><p>NOTE: as implied by the <code>git</code> argument <code>--recurse-submodules</code>, this repo uses submodules, so clones of this repo will always require <code>--recurse-submodules</code> argument if you want unit tests to work :D.</p>
<p>This repository has github actions setup to automatically build and run unit tests on each branch. Therefore, no local editor and tooling is technically necessary, you can simply edit your branch in the browser and commit most of the time and see the results. It will probably be faster to develop, build and test locally though.</p>
<p>I have provided the solutions for all code in the <code>main</code> branch. It is <em>intended</em> that you use this branch as reference. I do not want you to write your own solutions (though I have no problem if you do that on your own time). I literally expect participants to do the following:</p><ul>
<li>open <code>main</code> branch in their browser on right side of your screen (or other monitor)</li>
<li>open your branch in your code editor on the left side of your screen (or other monitor)</li>
<li>type <em>BY HAND</em> each unit test solution (and relevant algorithm implementation in <code>inc/algorithm.hpp</code> or <code>inc/detail/algorithm.hpp</code> when necessary), into your branch<ul>
<li><em>NO COPY PASTE</em>. The point of this unit test is to force all parts of your brain to engage with the learning process</li>
</ul>
</li>
<li>optionally, compile and run the unit tests locally with <code>cmake . &amp;&amp; make cpp_template_workshop_ut &amp;&amp; tst/cpp_template_workshop_ut</code><ul>
<li>a single unit test can be run with <code>tst/cpp_template_workshop_ut unit_test_name</code></li>
</ul>
</li>
<li><code>git add</code>, <code>commit</code>, and <code>push</code> your changes to your remote branch</li>
<li>see if the github action succeeds in compiling and the relevant unit tests pass</li>
</ul>
<p>unit tests can be run an built locally assuming you have <code>cmake</code> and a <code>c++</code> compiler installed which supports <code>c++11</code>. To configure build: </p><div class="fragment"><div class="line">cd /path/to/checkout/directory</div>
<div class="line">cmake .</div>
</div><!-- fragment --><p>To build and run unit tests: </p><div class="fragment"><div class="line">make cpp_template_workshop_ut </div>
<div class="line">./tst/cpp_template_workshop_ut</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md67"></a>
Simple C++ Algorithms</h2>
<p>This repository's <code>main</code> branch implements a set of high level algorithms which operate on containers and user Callables.</p>
<p><a href="https://durandaltheta.github.io/cpp_template_workshop/namespacesca.html">Doxygen Algorithm Documentation</a></p>
<p>The header <a href="inc/scalgorithm.hpp">scalgorithm.hpp</a> and convenience header <a href="inc/scalgorithm">scalgorithm</a> can be included in a project as-is. They can also be installed on your machine with: </p><div class="fragment"><div class="line">cmake .</div>
<div class="line">sudo make install </div>
</div><!-- fragment --><p>One of the targets of this course is to imbue students with the knowledge required to make <code>template</code> code of a high enough quality it can be used in real projects. Aside from the unit tests and extra credit work, which test the templates, students can easily experiment with the provided algorithms at their leasure to prove to themselves that what they are learning is, in fact, the real deal. Of course, if you find any bugs, please contribute a pull request :).</p>
<h2><a class="anchor" id="autotoc_md68"></a>
Grading</h2>
<p>Grading for this workshop is a scale of 1-5 (1 is bad, 3 is you completed the workshop, 5 is perfect).</p>
<ul>
<li>a branch checkout in their user name exists at end of workshop: 1 point<ul>
<li>if no branch checkout in their user name exists at the end of the workshop I will assume the user has not participated. This means no score, good or bad, will be forwarded to any line manager</li>
</ul>
</li>
<li>implement solution provided unit tests<ul>
<li>every 25% of solution provided unit tests passing grants 1 point (up to a total of 2 points)</li>
</ul>
</li>
<li>implement extra credit unit tests<ul>
<li>every 25% of extra credit unit tests passing grants 1 point (up to a total of 2 points)</li>
</ul>
</li>
</ul>
<p>Possible point total: 5</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Template theory - when to use templates?</h2>
<p>Here are my opinions on the topic:</p>
<p>Shorthand Rule:</p><ul>
<li>library code should use templates in its API to improve its capabilities</li>
<li>normal project code should often avoid writing custom templates</li>
</ul>
<p>However, in cases where the code in question is any of the following then templates and inlining are often a good solution, even in normal project code:</p><ul>
<li>function API can handle a variable number of arguments</li>
<li>frequently used algorithm follows a similar pattern with different types</li>
<li>frequently used algorithm follows a similar pattern which wraps executing code inside another function</li>
<li>compiler maximum runtime speed optimization is required (at the expense of potentially longer startup load times)</li>
</ul>
<p>Additionally, templates are just functions (that will been finalized by the compiler as needed), and can be used to write difficult and/or dangerous code just like normal functions. This means, more generally, that <em>templates expand your ability to abstract code</em> by leveraging their expanded featureset.</p>
<p>An example of several of the above issues: you need to launch a child thread which does some initialization but the parent thread wants to wait till the child completes initialization before moving on.</p>
<p>This can happen when using <code>std::thread</code>s where a signal handler needs to be set on the child thread in a synchronized way to avoid a race condition. Unfortunately, <code>std::thread</code> automatically launches its system thread without allowing for pre-configuration of it's signal handlers. Worse still, you have to do something similar (but different) on multiple threads throughout your program!</p>
<p>Now you have to do some scary <code>std::condition_variable</code> blocking to wait for your child <code>std::thread</code> to complete the necessary initialization. Wouldn't it be nice to write a pattern of code which could do this <em>dangerous</em> operation <em>multiple times</em> in <em>different ways</em> with an <em>undefined number of arguments</em> that was maintainable from a <em>single template function</em>?</p>
<p>Example Solution (if this doesn't make sense right away, consider coming back here throughout the workshop to re-examine with your new knowledge). In some header: </p><div class="fragment"><div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &lt;mutex&gt;</div>
<div class="line">#include &lt;condition_variable&gt;</div>
<div class="line">#include &lt;memory&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename InitFunction, typename Function, typename... OptionalArgs&gt;</div>
<div class="line">std::thread init_thread(InitFunction&amp;&amp; init_f, Function&amp;&amp; f, OptionalArgs&amp;&amp;... args) {</div>
<div class="line">    // figure out the scary synchronization once</div>
<div class="line">    std::mutex mtx;</div>
<div class="line">    std::condition_variable cv;</div>
<div class="line">    bool flag = false;</div>
<div class="line"> </div>
<div class="line">    std::thread thd([=, &amp;mtx, &amp;cv, &amp;flag]() mutable {</div>
<div class="line">        // do thread initialization</div>
<div class="line">        init_f();</div>
<div class="line"> </div>
<div class="line">        // notify parent thread initialization is complete</div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lk(mtx);</div>
<div class="line">            flag = true;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        cv.notify_one();</div>
<div class="line"> </div>
<div class="line">        // proceed with regular thread operation</div>
<div class="line">        f(std::forward&lt;OptionalArgs&gt;(args)...);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    // wait for thread initialization</div>
<div class="line">    {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lk(mtx);</div>
<div class="line"> </div>
<div class="line">        while(!flag) {</div>
<div class="line">            cv.wait(lk);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // don&#39;t need to move local variable, compiler will use copy elision </div>
<div class="line">    // https://en.cppreference.com/w/cpp/language/copy_elision</div>
<div class="line">    return thd; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Then you can use your new (and safe!) function throughout your program: </p><div class="fragment"><div class="line">#include &lt;pthread.h&gt;</div>
<div class="line">#include &lt;unistd.h&gt;</div>
<div class="line">#include &lt;thread&gt;</div>
<div class="line">#include &quot;some_header_with_your_init_thread_template.hpp&quot;</div>
<div class="line"> </div>
<div class="line">std::thread g_my_child_1;</div>
<div class="line">std::thread g_my_child_2;</div>
<div class="line"> </div>
<div class="line">void set_handler(void(*sig_handler)(int)) {</div>
<div class="line">    sigaction new_action, old_action;</div>
<div class="line">    new_action.sa_handler = sig_handler;</div>
<div class="line">    sigemptyset (&amp;new_action.sa_mask);</div>
<div class="line">    new_action.sa_flags = 0;</div>
<div class="line"> </div>
<div class="line">    sigaction (SIGINT, NULL, &amp;old_action);</div>
<div class="line">    if (old_action.sa_handler != SIG_IGN) {</div>
<div class="line">        sigaction (SIGINT, &amp;new_action, NULL);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    //set other handlers...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void my_child_1_sighdl(int sig) {</div>
<div class="line">    std::cout &lt;&lt; &quot;child 1 received signal[&quot; &lt;&lt; sig &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void my_child_2_sighdl(int sig) {</div>
<div class="line">    std::cout &lt;&lt; &quot;child 2 received signal[&quot; &lt;&lt; sig &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void child_func_1(const char* arg0, const char* arg1) {</div>
<div class="line">    // use arg0 and arg1 to rule the world</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void child_func_2() {</div>
<div class="line">    // rule the world without relying on the crutch of arguments</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void launch_my_child_threads() {</div>
<div class="line">    // use some lambdas to easily call set_handler() during thread initialization</div>
<div class="line">    g_my_child_1 = init_thread([]{ set_handler(my_child_1_sighdl); }, child_func_1, &quot;everybody wants to rule the&quot;, &quot;world&quot;);</div>
<div class="line">    g_my_child_2 = init_thread([]{ set_handler(my_child_2_sighdl); }, child_func_2);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md70"></a>
Lesson Notes</h1>
<p>Here are the links to all the lesson notes. We will meet regularly (probably every 2 weeks or so) where I will go through the lesson notes and have extended question/answer session (if necessary). We can live debug together if necessary, though I can't promise I can immediately solve every problem on the spot :D. The goal is you should do your unit tests sometime in the intervening days, though I won't track your progress (and I don't care! I only care about helping you learn this skill).</p>
<ul>
<li><a class="el" href="md_lesson_1_basic_templates_part_1.html">Lesson 1: Basic Templates Part 1</a> &ndash; <a href="tst/lesson_1_ut.cpp">unit tests</a></li>
<li><a class="el" href="md_lesson_2_basic_templates_part_2.html">Lesson 2: Basic Templates Part 2</a> &ndash; <a href="tst/lesson_2_ut.cpp">unit tests</a></li>
<li><a class="el" href="md_lesson_3_type_erasure.html">Lesson 3: Type Erasure</a> &ndash; <a href="tst/lesson_3_ut.cpp">unit tests</a></li>
<li>Lesson 4: Substitution Failure Is Not An Error &ndash; <a href="tst/lesson_4_ut.cpp">unit tests</a></li>
<li><a class="el" href="md_lesson_5_callables.html">Lesson 5: Callables</a> &ndash; <a href="tst/lesson_5_ut.cpp">unit tests</a></li>
<li><a class="el" href="md_lesson_6_variadic_templates.html">Lesson 6: Variadic Templates</a> &ndash; <a href="tst/lesson_6_ut.cpp">unit tests</a></li>
<li><a class="el" href="md_lesson_7_putting_it_all_together.html">Lesson 7: Putting it All Together</a> &ndash; <a href="tst/lesson_7_ut.cpp">unit tests</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
