<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple thread: Lambdas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple thread
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Lambdas </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
A Gentle Introduction</h1>
<p>Lambdas (or "closures" or "anonymous functions") are functions that are created initially without a name and can be created within other functions. This is very different from classic C/C++, where all functions have names and functions cannot normally be defined inside another function.</p>
<p>Practically speaking, this just means that lambdas are functions that are also variables, and can be manipulated like any other variable. Lambdas follow this pattern in c++: </p><div class="fragment"><div class="line">[capture0, ..., captureN](arg0, ..., argN){ statement0; ...; statmentN; };</div>
</div><!-- fragment --><p>Lambdas can be stored as a variable using their real type (specified by the compiler) using keyword <code>auto</code>: </p><div class="fragment"><div class="line">auto my_lambda = [capture0, ..., captureN](arg0, ..., argN){ statement0; ...; statmentN; };</div>
</div><!-- fragment --><p>Lambdas can also be stored in a std::function object, which looks like this: </p><div class="fragment"><div class="line">std::function&lt;function_return_type(arg_0_type, ..., arg_N_type)&gt; object_name;</div>
<div class="line">object_name = [capture0, ..., captureN](arg0, ..., argN){ statement0; ...; statmentN; };</div>
</div><!-- fragment --><p>Lambdas can be invoked using parenthesis '()' with their required arguments. What this might look like in example code: </p><div class="fragment"><div class="line">#include &lt;functional&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv) {</div>
<div class="line">    // the &quot;auto&quot; keyword can be used here instead for my_lambda&#39;s type</div>
<div class="line">    std::function&lt;int(int,int)&gt; my_lambda = [](int a, int b){ return a + b; };</div>
<div class="line"> </div>
<div class="line">    // the following prints &quot;my_lambda: 5&quot;</div>
<div class="line">    std::cout &lt;&lt; &quot;my_lambda: &quot; &lt;&lt; my_lambda(2,3) &lt;&lt; std::endl; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Whitespace is arbitrary in lambdas, and can be written in different ways if the function has many statements: </p><div class="fragment"><div class="line">void func(int a, int b, int c, int d) {</div>
<div class="line">    auto l = [](int a, int b, int c, int d) {</div>
<div class="line">        const int e = c + a;</div>
<div class="line">        const int f = e + b - d;</div>
<div class="line">        return f;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;lambda output: &quot; &lt;&lt; l(1,2,3,4) &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Lambda Captures</h1>
<p>Lambdas can also "capture" values or references from the enclosing scope. This is similar to the behavior of functions with global variables or other normal functions. Example: </p><div class="fragment"><div class="line">#include &lt;functional&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char**argv) {</div>
<div class="line">    int a = 2;</div>
<div class="line">    int b = 3;</div>
<div class="line">    auto my_lambda = [a,b](){ return a + b };</div>
<div class="line"> </div>
<div class="line">    // the following still prints &quot;my_lambda: 5&quot;. Notice how it takes no </div>
<div class="line">    // arguments.</div>
<div class="line">    std::cout &lt;&lt; &quot;my_lambda: &quot; &lt;&lt; my_lambda() &lt;&lt; std::endl; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Lambdas can capture by value: </p><div class="fragment"><div class="line">[my_variable,...](...){...};</div>
</div><!-- fragment --><p>Or by reference: </p><div class="fragment"><div class="line">[&amp;my_variable,...](..){...};</div>
</div><!-- fragment --><p>Capturing by reference allows the user to refer back to the original variable, and potentially modify it.</p>
<p>Values or references can be automatically captured as needed if given a '=' or '&amp;' at the beginning of the capture clause. IE, If the first "variable" in the capture clause is a "=" it will implicitly capture any variable not specified in the clause by value as required. If the first "variable" in the capture clause is instead a "&amp;" values will implicitly be captured by reference instead: </p><div class="fragment"><div class="line">[=](..){...}; //default automatic const value capture</div>
<div class="line">[&amp;](..){...}; //default automatic mutable reference capture</div>
</div><!-- fragment --><p>Even if a default, automatic capture behavior is specified, additional captures can still be specified that use the same or opposite behavior: </p><div class="fragment"><div class="line">[=,&amp;a_local_reference,a_local_value,...](..){...};</div>
<div class="line">[&amp;,a_local_value,&amp;a_local_reference,...](..){...};</div>
</div><!-- fragment --><p>Lambda captures by value are const by default. This allows lambdas to be dynamically constructed on the stack and to pass around state without modifying it.</p>
<div class="fragment"><div class="line">int high_level_func() {</div>
<div class="line">    int i = 5;</div>
<div class="line">    int u = 6;</div>
<div class="line"> </div>
<div class="line">    // i and u cannot be modified by the lambda even though they are not </div>
<div class="line">    // defined const, making this lambda adhere to the functional paradigm</div>
<div class="line">    auto l = [=]{ return i + u; };</div>
<div class="line"> </div>
<div class="line">    return l(); // return 11</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3"></a>
Returning Lambdas</h1>
<p>Lambdas can also be returned. Functions that take <em>other</em> functions as arguments or return <em>other</em> functions are called "higher order functions":</p>
<div class="fragment"><div class="line">std::function&lt;int()&gt; high_level_func() {</div>
<div class="line">    int i = 5;</div>
<div class="line">    int u = 6;</div>
<div class="line"> </div>
<div class="line">    auto l = [=]{ return i + u; };</div>
<div class="line"> </div>
<div class="line">    return l; // return the lambda &#39;l&#39; to calling context</div>
<div class="line">}</div>
</div><!-- fragment --><p>The main purpose of passing lambdas around is as a method of passing state. Instead of passing around 10 variables from 5 functions, some of the calculation can be done in one place and passed to another function that knows what is needed to complete the calculation.</p>
<p>This is effectively a form of data hiding that is even more private than structs and objects. That is, when passing data around via <code>class</code> or <code>struct</code> objects all parties that read the data must include relevant headers for that structure that describes its members, typically public and private. This is not the case with lambdas and <code>std::function</code>, whose internals are completely unknown to code which uses them, minimizing the amount of boilerplate and knowledge required to use them.</p>
<p>In the case of lambda captures, what is being passed is much more specialized, and the recipient doesn't need to know <em>anything</em> about the internals of the function other than its return type and argument types, making message passing and interfaces much easier and even more of black box. Thus:</p>
<div class="fragment"><div class="line">std::function&lt;int(int)&gt; give_closure(int a, int b, int c) {</div>
<div class="line">    return [=](int d) {</div>
<div class="line">        // The eventual user of this function knows *nothing* about a, b, and </div>
<div class="line">        // c. It doesn&#39;t need to know anything other than it is a </div>
<div class="line">        // std::function&lt;int(int)&gt; and what the return value is supposed to </div>
<div class="line">        // represent.</div>
<div class="line">        return (a + b - c) * d;</div>
<div class="line">    };</div>
<div class="line">}</div>
</div><!-- fragment --><p>A function generated by give_closure() will function even if passed to another thread! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
