<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: Lambdas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Lambdas </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
A Gentle Introduction</h1>
<p>Lambdas (or "closures" or "anonymous functions") are functions that are created initially without a name and can be created within other functions. This is very different from classic C/C++, where all functions have names and functions cannot normally be defined inside another function.</p>
<p>Practically speaking, this just means that lambdas are functions that are also variables, and can be manipulated like any other variable. Lambdas follow this pattern in c++: </p><div class="fragment"><div class="line">[capture0, ..., captureN](arg0, ..., argN){ statement0; ...; statmentN; };</div>
</div><!-- fragment --><p>Lambdas can be stored as a variable using their real type (specified by the compiler) using keyword <code>auto</code>: </p><div class="fragment"><div class="line">auto my_lambda = [capture0, ..., captureN](arg0, ..., argN){ statement0; ...; statmentN; };</div>
</div><!-- fragment --><p>Lambdas can also be stored in a <code>std::function</code> object, which looks like this: </p><div class="fragment"><div class="line">std::function&lt;function_return_type(arg_0_type, ..., arg_N_type)&gt; object_name;</div>
<div class="line">object_name = [capture0, ..., captureN](arg0, ..., argN){ statement0; ...; statmentN; };</div>
</div><!-- fragment --><p>Lambdas can be invoked using parenthesis <code>()</code> with their required arguments. What this might look like in example code: </p><div class="fragment"><div class="line">#include &lt;functional&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // the &quot;auto&quot; keyword can be used here instead for my_lambda&#39;s type</div>
<div class="line">    std::function&lt;int(int,int)&gt; my_lambda = [](int a, int b){ return a + b; };</div>
<div class="line"> </div>
<div class="line">    // the following prints &quot;my_lambda: 5&quot;</div>
<div class="line">    std::cout &lt;&lt; &quot;my_lambda: &quot; &lt;&lt; my_lambda(2,3) &lt;&lt; std::endl; </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Whitespace</h1>
<p>Whitespace is arbitrary in lambdas, and can be written in different ways if the function has many statements: </p><div class="fragment"><div class="line">void func(int a, int b, int c, int d) {</div>
<div class="line">    auto l = [](int a, int b, int c, int d) {</div>
<div class="line">        const int e = c + a;</div>
<div class="line">        const int f = e + b - d;</div>
<div class="line">        return f;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;lambda output: &quot; &lt;&lt; l(1,2,3,4) &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3"></a>
Inline invocation</h1>
<p>Lambdas can be invoked inline with <code>()</code>: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // the following prints &quot;3&quot; on the terminal</div>
<div class="line">    std::cout &lt;&lt; [](int i){ return i + 1; }(3) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Omitting Parenthesis</h1>
<p>If no arguments are used by the lambda, then the parenthesis clause <code>()</code> after the capture clause <code>[]</code> can be omitted: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; []{ return std::string(&quot;hello world&quot;); } &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Lambda Return Types</h1>
<p>The compiler tends to do a pretty good job of deducing the return type of lambdas based on their return statement. However, lambdas can explicitly specify their return type if necessary, something that can be useful when the return type is ambiguous. To specify the return type, the following form is used (the arguments parenthesis clause is required <code>()</code>): </p><div class="fragment"><div class="line">[... required capture clause ...](... required arguments clause...) -&gt; ReturnType { ... statements ... }</div>
</div><!-- fragment --><p>Usage can look something like this: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; []() -&gt; std::string { return &quot;hello world&quot;; } &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Lambda Captures</h1>
<p>Lambdas can also "capture" values or references from the enclosing scope. This is similar to the behavior of functions with global variables or other normal functions. Example: </p><div class="fragment"><div class="line">#include &lt;functional&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int a = 2;</div>
<div class="line">    int b = 3;</div>
<div class="line">    auto my_lambda = [a,b](){ return a + b };</div>
<div class="line"> </div>
<div class="line">    // the following still prints &quot;my_lambda: 5&quot;. Notice how it takes no </div>
<div class="line">    // arguments.</div>
<div class="line">    std::cout &lt;&lt; &quot;my_lambda: &quot; &lt;&lt; my_lambda() &lt;&lt; std::endl; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Lambdas can capture by value: </p><div class="fragment"><div class="line">[my_variable,...](...){...};</div>
</div><!-- fragment --><p>Or by reference: </p><div class="fragment"><div class="line">[&amp;my_variable,...](..){...};</div>
</div><!-- fragment --><p>Capturing by reference allows the user to refer back to the original variable, and potentially modify it.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Automatic Lambda Captures</h1>
<p>Values or references can be automatically captured as needed if given a '=' or '&amp;' at the beginning of the capture clause. IE, If the first "variable" in the capture clause is a "=" it will implicitly capture any variable not specified in the clause by value as required. If the first "variable" in the capture clause is instead a "&amp;" values will implicitly be captured by reference instead: </p><div class="fragment"><div class="line">[=](..){...}; //default automatic const value capture</div>
<div class="line">[&amp;](..){...}; //default automatic mutable reference capture</div>
</div><!-- fragment --><p>Even if a default, automatic capture behavior is specified, additional captures can still be specified that use the same or opposite behavior: </p><div class="fragment"><div class="line">[=,&amp;a_local_reference,a_local_value,...](..){...};</div>
<div class="line">[&amp;,a_local_value,&amp;a_local_reference,...](..){...};</div>
</div><!-- fragment --><p>Automatic captures allow for simpler invocations: </p><div class="fragment"><div class="line">#include &lt;functional&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int i = 5;</div>
<div class="line">    int u = 6;</div>
<div class="line">    std::cout &lt;&lt; [=]{ return i + u; }() &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
By Value Const and Mutable Semantics</h1>
<p>Lambda captures by value are const by default. This allows lambdas to be dynamically constructed on the stack and to pass around state without modifying it, potentially implementing some compiler optimization: </p><div class="fragment"><div class="line">int high_level_func() {</div>
<div class="line">    int i = 5;</div>
<div class="line">    int u = 6;</div>
<div class="line"> </div>
<div class="line">    // i and u cannot be modified by the lambda even though they are not </div>
<div class="line">    // defined const, making this lambda adhere to the functional paradigm</div>
<div class="line">    auto l = [=]{ return i + u; };</div>
<div class="line"> </div>
<div class="line">    return l(); // return 11</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the user needs to make by value captures mutable, the following lambda format must be used with the <code>mutable</code> keyword. Note, with this variant the argument parenthesis clause <code>()</code> can <em>never</em> be omitted: </p><div class="fragment"><div class="line">[=, ... other captures ...](... required parenthesis clause ...) mutable { ... lambda statements ... }</div>
</div><!-- fragment --><p>With the above format the lambda can write to captures: </p><div class="fragment"><div class="line">int high_level_func() {</div>
<div class="line">    int i = 5;</div>
<div class="line">    int u = 6;</div>
<div class="line"> </div>
<div class="line">    auto l = [=]() mutable { </div>
<div class="line">        ++i;</div>
<div class="line">        ++u;</div>
<div class="line">        return i + u; </div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    return l(); // return 13</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
Capture Initializers</h1>
<p>A feature added to <code>c++14</code> is the ability to initialize a capture with a value. This might be useful if the user needs to capture an incremented number: </p><div class="fragment"><div class="line">void some_func() {</div>
<div class="line">    //...</div>
<div class="line">    int i = 14;</div>
<div class="line">    //...</div>
<div class="line">    auto l = [i = i + 1]{ return i; }; // captured i == 15</div>
<div class="line">    //... </div>
<div class="line">}</div>
</div><!-- fragment --><p>This feature may seem trivial but it allows rvalue <code>std::move()</code> assignment and perfect forwarding using <code>std::forward&lt;T&gt;</code>: </p><div class="fragment"><div class="line">template &lt;typename T&gt;</div>
<div class="line">void some_func(T&amp;&amp; t) { // t is a universal reference </div>
<div class="line">    //...</div>
<div class="line">    auto l = [t = std::forward&lt;T&gt;(t)]{ // captured t is moved or copied as required</div>
<div class="line">        // do something with t</div>
<div class="line">    }; </div>
<div class="line">    //... </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Returning Lambdas</h1>
<p>Lambdas can also be returned. Functions that take <em>other</em> functions as arguments or return <em>other</em> functions are called "higher order functions":</p>
<div class="fragment"><div class="line">std::function&lt;int()&gt; high_level_func() {</div>
<div class="line">    int i = 5;</div>
<div class="line">    int u = 6;</div>
<div class="line"> </div>
<div class="line">    auto l = [=]{ return i + u; };</div>
<div class="line"> </div>
<div class="line">    return l; // return the lambda &#39;l&#39; to calling context</div>
<div class="line">}</div>
</div><!-- fragment --><p>The main purpose of passing lambdas around is as a method of passing state. Instead of passing around 10 variables from 5 functions, some of the calculation can be done in one place and passed to another function that knows what is needed to complete the calculation.</p>
<p>This is effectively a form of data hiding that is even more private than structs and objects. That is, when passing data around via <code>class</code> or <code>struct</code> objects all parties that read the data must include relevant headers for that structure that describes its members, typically public and private. This is not the case with lambdas and <code>std::function</code>, whose internals are completely unknown to code which uses them, minimizing the amount of boilerplate and knowledge required to use them.</p>
<p>In the case of lambda captures, what is being passed is much more specialized, and the recipient doesn't need to know <em>anything</em> about the internals of the function other than its return type and argument types, making message passing and interfaces much easier and even more of black box. Thus:</p>
<div class="fragment"><div class="line">std::function&lt;int(int)&gt; give_closure(int a, int b, int c) {</div>
<div class="line">    return [=](int d) {</div>
<div class="line">        // The eventual user of this function knows *nothing* about a, b, and </div>
<div class="line">        // c. It doesn&#39;t need to know anything other than it is a </div>
<div class="line">        // std::function&lt;int(int)&gt; and what the return value is supposed to </div>
<div class="line">        // represent.</div>
<div class="line">        return (a + b - c) * d;</div>
<div class="line">    };</div>
<div class="line">}</div>
</div><!-- fragment --><p>A function generated by give_closure() will function even if passed to another thread! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
