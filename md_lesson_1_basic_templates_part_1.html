<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple thread: Basic Templates Part 1</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple thread
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Basic Templates Part 1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md5"></a>
What Are Templates?</h1>
<p>In <code>c++</code> a template is a recipe for code that the compiler will finish writing for you <em>as needed</em> (and not before!). Templates always begin with the keyword <code>template</code>, followed by a template parameter list beginning with a <code>&lt;</code> and ending with a <code>&gt;</code>. Within the <code>template</code> parameter list you can specify templated types with the keywords <code>typename</code> or <code>class</code>.</p>
<p>After the <code>template</code> header follows a function, a <code>struct</code>/<code>class</code> definition, or a <code>using typename =</code> type alias.</p>
<p>A psuedo-code example: </p><div class="fragment"><div class="line">template &lt;typename T&gt;`</div>
<div class="line">void my_template_function(T t) {</div>
<div class="line">    // do things...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">void my_template_function2(T t) {</div>
<div class="line">    // do other things...</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is important to note that <code>c++</code> templates are <em>recipes</em> for final code, <em>NOT</em> the final code itself. This means that final <code>c++</code> code is <em>not generated by the compiler until a template is called in code</em>. This is extremely useful in some ways, but it can leave unexpected errors in the code where a template will not be able to generate valid code for some types if your templates are not thoroughly unit tested!</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Manual Type Specification</h1>
<p>The <code>typename</code>/<code>class</code> types defined in a <code>template</code> are known until the <code>template</code> is called in code. This means a template has the ability to <em>potentially</em> represent valid code for different types.</p>
<p>The most basic way a template is called in code is to write the name of the <code>template</code> followed by <code>&lt;</code>/<code>&gt;</code> brackets enclosing the types you want to use. You should immediately recognize this pattern with <code>std::vector</code>: </p><div class="fragment"><div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // `std::vector` is a template class</div>
<div class="line">    std::vector&lt;int&gt; v{1,2,3};</div>
<div class="line"> </div>
<div class="line">    for(auto&amp; e : v) {</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">1 2 3 </div>
<div class="line">$</div>
</div><!-- fragment --><p>Consider the fact <code>c++</code> allows different implementations of the same function as long as they follow <a href="https://en.cppreference.com/w/cpp/language/overload_resolution">overload resolution rules</a>. For example, both <code>int</code> and <code>std::string</code> can be "added" together using the <code>+</code> operator.</p>
<p>Textually, the <code>+</code> is just a symbol that happens to have multiple meanings. Under the hood, the <code>+</code> operator is just a function and <code>c++</code> allows you overload these operators as you desire. Templates allow you to use this ambiguity to write 'code recipes' which the compiler can use in multiple circumstances. Take this <code>template</code> example using <code>+</code>: </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">T add(T t1, T t2) {</div>
<div class="line">    return t1 + t2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; add&lt;int&gt;(1, 2) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add&lt;std::string&gt;(std::string(&quot;hello &quot;),  std::string(&quot;world&quot;)) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">3</div>
<div class="line">hello world</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Type Deduction</h1>
<p>One of the most useful aspects of <code>c++</code> <code>template</code>s is the fact that the compiler can often determine the final types <em>without</em> needing to use <code>&lt;</code>/<code>&gt;</code> brackets. Using our <code>add</code> template again: </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">T add(T t1, T t2) {</div>
<div class="line">    return t1 + t2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // the compiler has enough information just by calling add() with integers</div>
<div class="line">    // or std::strings that it can finish the template without &lt;&gt; brackets.</div>
<div class="line">    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add(std::string(&quot;hello &quot;),  std::string(&quot;world&quot;)) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">3</div>
<div class="line">hello world</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Multiple Template Types</h1>
<p>There's no limitation on the number of templated types a template can have. This allows us to write templates which can take more than one unknown argument type. Rewriting out <code>add</code> template: </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, typename T2&gt;</div>
<div class="line">T add(T t1, T2 t2) {</div>
<div class="line">    return t1 + t2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;</div>
<div class="line">    // compiler type coerces double to an integer inside the internal `+` function</div>
<div class="line">    std::cout &lt;&lt; add(1, 2.0) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add(1.0, 2.0) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">3</div>
<div class="line">3</div>
<div class="line">3.0</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
Type Specialization</h1>
<p>Sometimes you need explicitly write different behavior for specific subcases. This can be accomplished by writing more specific versions of your template alongside more general ones. </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, typename T2&gt;</div>
<div class="line">T add(T t1, T2 t2) {</div>
<div class="line">    return t1 + t2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">std::string add(std::string s, T t) {</div>
<div class="line">    return s + std::to_string(t);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">std::string add(T t, std::string s) {</div>
<div class="line">    return std::to_string(t) + s;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add(std::string(&quot;number: &quot;, 3.0) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add(3, std::string(&quot;is also a number &quot;) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">3</div>
<div class="line">number: 3.0</div>
<div class="line">3 is also a number</div>
<div class="line">$</div>
</div><!-- fragment --><p>The order that template specializations are written can be quite in important for selecting the proper case. This is a whole topic in and of itself, but it should be noted that the compiler likes to take the <em>most specialized</em> valid template it can use when it needs one (the template which can be used in the smallest subset of usecases).</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Default Type Assignment</h1>
<p>One final point is that templates types can have default values. This is often then case when a library template code supports a primary way of doing something in a template, but leaves the door open for custom overrides. When using a default type assignment the user does not have to specify the type in <code>&lt;</code>/<code>&gt;</code> brackets if a type is assigned via <code>=</code>. Such is the case with <code>std::vector</code>, whose template class declaration is as follows: </p><div class="fragment"><div class="line">template&lt;</div>
<div class="line"> class T,</div>
<div class="line"> class Allocator = std::allocator&lt;T&gt;</div>
<div class="line">&gt; class vector;</div>
</div><!-- fragment --><p>This means that a <code>std::vector&lt;int&gt;</code> (where <code>T</code> is set to <code>int</code>) is more of a nickname for the actual <code>std::vector</code> type. The <em>actual</em> type is <code>std::vector&lt;int, std::allocator&lt;int&gt;&gt;</code>, but the compiler doesn't require you specify the <code>Allocator</code> type if you use the default allocator.</p>
<p>Here is an example where a template has a default type: </p><div class="fragment"><div class="line">#include &lt;vector&gt; </div>
<div class="line">#include &lt;list&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, typename Container = std::vector&lt;T&gt;&gt;</div>
<div class="line">Container construct_container_with_one_element(T t) {</div>
<div class="line">    return Container{t};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; v = construct_container_with_one_element(1);</div>
<div class="line">    std::list&lt;int&gt; l = construct_container_with_one_element&lt;int, std::list&lt;int&gt;&gt;(2);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; v.front() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; l.front() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">1</div>
<div class="line">2</div>
<div class="line">$</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
