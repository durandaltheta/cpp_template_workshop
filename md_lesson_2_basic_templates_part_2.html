<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple thread: Basic Templates Part 2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple thread
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Basic Templates Part 2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md12"></a>
Lvalues and Rvalues</h1>
<h2><a class="anchor" id="autotoc_md13"></a>
What are they?</h2>
<p><code>lvalue</code>s and <code>rvalue</code>s are a concept in <code>c++</code> called <a href="https://en.cppreference.com/w/cpp/language/value_category">value categories</a>. However, that hyperlinked list is <em>extremely</em> confusing and contains many sub-categories which are commonly also called <code>lvalue</code>s or <code>rvalue</code>s but are in fact some other value type (<code>prvalue</code>, <code>xvalue</code>, etc.).</p>
<p>Historically, an <code>lvalue</code> might be described as the value on the left side of a statement, whereas an rvalue is on the right side. The classic example is an assignment: </p><div class="fragment"><div class="line">int i_am_an_lvalue = 3; // 3 is an rvalue</div>
</div><!-- fragment --><p>However, the exceptions to this case are enormous, because the right hand side of a statement can <em>very easily</em> be an lvalue: </p><div class="fragment"><div class="line">int i_am_an_lvalue = 3; </div>
<div class="line">int i_am_also_an_lvalue = i_am_an_lvalue; // both sides are still lvalues!</div>
</div><!-- fragment --><p>Here is a quote about the difference between lvalues and rvalues from computer scientist Scott Meyers (taken from <a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers</a>) </p><blockquote class="doxtable">
<p>A precise definition for these terms is difficult to develop (the C++11 standard generally specifies whether an expression is an lvalue or an rvalue on a case-by-case basis), but in practice, the following suffices:</p>
<p>If you can take the address of an expression, the expression is an lvalue. If the type of an expression is an lvalue reference (e.g., T&amp; or const T&amp;, etc.), that expression is an lvalue. Otherwise, the expression is an rvalue. Conceptually (and typically also in fact), rvalues correspond to temporary objects, such as those returned from functions or created through implicit type conversions. Most literal values (e.g., 10 and 5.3) are also rvalues. </p>
</blockquote>
<p>To further simplify what Scott described you can generalize the two value categories as such:</p>
<h3><a class="anchor" id="autotoc_md14"></a>
rvalue</h3>
<p>Any variable or object which is going to go out of existence after the current statement. Examples: </p><div class="fragment"><div class="line">int a_variable = 3; // 3 is an rvalue</div>
<div class="line"> </div>
<div class="line">struct my_struct { };</div>
<div class="line"> </div>
<div class="line">// the &quot;my_struct()&quot; on the right side of the assignment is an rvalue </div>
<div class="line">auto my_struct_instance = my_struct(); </div>
<div class="line"> </div>
<div class="line">// std::move() forces a_variable to appear as an rvalue during the assignment</div>
<div class="line">int another_variable = std::move(a_variable);</div>
<div class="line"> </div>
<div class="line">int add_1(int&amp;&amp; i) { // double ampersand reference to i is an rvalue</div>
<div class="line">    return i + 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
lvalue</h3>
<p>Every other kind of variable or object: </p><div class="fragment"><div class="line">int a_variable; // lvalue</div>
<div class="line"> </div>
<div class="line">struct my_struct {</div>
<div class="line">    int my_member_variable; // lvalue</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">my_struct my_struct_instance; // lvalue </div>
<div class="line"> </div>
<div class="line">int add_3(int&amp; i) { // reference to i is an lvalue</div>
<div class="line">    return i + 3;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int sub_2(const int&amp; i) { // const reference to i is an lvalue</div>
<div class="line">    return i - 2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This doesn't capture the <em>exact</em> meaning, you may need to refer to the <a href="https://en.cppreference.com/w/cpp/language/value_category">value categories</a> page for greater detail, but in my experience this is a useful mental model, because the utility this concept brings to <code>c++</code> programming is tied to the idea of something "about to go out of existence" which in turn enables something called "rvalue move semantics".</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Why are lvalues and rvalues important?</h2>
<p>In <code>c</code> there are two ways to store data, by-value (variables) and by-reference (pointers). Variables exist at a memory address, while pointers hold the value of <em>another</em> value's memory address.</p>
<p>Assigning values to variables is called a "deep copy", while assigning a variable to a pointer is a "shallow copy". All this means is that, if the variable is large (some kind of struct or array), deep copying to it is a more expensive operation than shallow copying, which only needs to assign a single value (the memory address). </p><div class="fragment"><div class="line">char str[10]; // a character buffer to hold our string</div>
<div class="line">memset(str, 0, sizeof(str));</div>
<div class="line">strncpy(str,&quot;hello world&quot;,sizeof(str)); // this is a deep copy</div>
<div class="line">char* str_ptr = &amp;str; // this is a shallow copy</div>
<div class="line">printf(&quot;%s&quot;, str_ptr); // prints &quot;hello world&quot;</div>
</div><!-- fragment --><p>The introduction of <code>rvalue</code>s to <code>c++</code> enables a higher order "in-between copy" called "swapping" using "rvalue move semantics".</p>
<p>An <code>std::string</code> contains an allocated buffer of characters. When the <code>std::string</code> is destroyed or reassigned it deallocates it's internal buffer of characters (and when reassigning allocates a <em>new</em> buffer to hold the new values). This means that a standard copy between named <code>std::string</code> variables is slower (often <em>much</em> slower) than copying only <code>char *</code> pointers. </p><div class="fragment"><div class="line">std::string s1 = &quot;hello world&quot;; // this is a deep copy, each char must be copied into s1&#39;s character buffer</div>
<div class="line">std::string s2 = s1; // this is also a deep copy</div>
</div><!-- fragment --><p>However, with "rvalue move semantics", if the compiler detects that the <code>std::string</code> on the right hand side is about to go out of existence (it is an <code>rvalue</code>) then the compiler knows it can safely <em>steal</em> the underlying <code>char *</code> buffer from that string and give it to the <code>std::string</code> on the left (actually the two <code>std::string</code> will exchange buffer pointers). This operation is called "swapping". Swapping turns a deep copy into a very shallow copy (for at least the string character buffer, other <code>std::string</code> members may need to be copied). </p><div class="fragment"><div class="line">std::string s1 = std::string(&quot;hello world&quot;); // rvalue makes this a shallow copy!</div>
<div class="line">std::string s2 = std::move(s1); // std::move() makes s1 an rvalue also making this a shallow copy!</div>
</div><!-- fragment --><p>The <code>c++</code> method <code>std::move()</code> (part of the <code>&lt;utility&gt;</code> standard library) turns an <code>lvalue</code> statement into an <code>rvalue</code> statement. It (alongside <code>std::forward&lt;T&gt;()</code>) are fairly standard tools when writing efficient templates.</p>
<p>A <code>swap</code> operation is at least 3 steps rather than one step that a true shallow copy provides. Example implementation of a swap: </p><div class="fragment"><div class="line">void swap(void* a, void* b) {</div>
<div class="line">    void* temp = a;</div>
<div class="line">    *a = b;</div>
<div class="line">    *b = temp; </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Lvalue and Rvalue References</h2>
<p>Most objects can be assigned or constructed using rvalues (operations which compiler may write for you if you don't explicitly write them for your objects). But how can we write code which recognizes an argument as an <code>rvalue</code>?</p>
<p>In <em>non-templates</em> the solution is to denote an <code>rvalue</code> reference by a double ampersand <code>&amp;&amp;</code>, instead of a single ampersand <code>&amp;</code> used in normal (lvalue!) references. In <em>templates</em> the double ampersand <code>&amp;&amp;</code> has special meaning, which we will address later.</p>
<p>A simple struct with a lvalue and rvalue constructors/assignment explicitly written: </p><div class="fragment"><div class="line">struct my_struct() {</div>
<div class="line">    // rhs is common shortand for &quot;right hand side&quot;</div>
<div class="line"> </div>
<div class="line">    my_struct(const my_struct&amp; rhs) // lvalue constructor</div>
<div class="line">        : m_str(rhs.m_str)</div>
<div class="line">    { }</div>
<div class="line"> </div>
<div class="line">    my_struct(my_struct&amp;&amp; rhs) // rvalue constructor</div>
<div class="line">        : m_str(std::move(rhs.m_str))</div>
<div class="line">    { }</div>
<div class="line"> </div>
<div class="line">    inline my_struct&amp; operator=(const my_struct&amp; rhs) { // lvalue assignment</div>
<div class="line">        m_str = rhs.m_str;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    inline my_struct&amp; operator=(my_struct&amp;&amp; rhs) { // rvalue assignment</div>
<div class="line">        m_str = std::move(rhs.m_str);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string m_str;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md18"></a>
Forwarding</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Moving vs Forwarding</h2>
<p><code>rvalues</code>, unless explicitly <code>std::move</code>ed or <code>std::forward</code>ed, will be automatically converted to <code>lvalues</code> when passed to subsequent functions in order to limit unintended side effects.</p>
<p>Forwarding is the method of taking either an <code>rvalue</code> or <code>lvalue</code> passed to a method/function and calling <em>another</em> method/function in such a way as to preserve the <code>rvalue</code>ness/<code>lvalue</code>ness in the subsequent call.</p>
<p>A call to <code>std::move()</code> will transform it's argument into an <code>rvalue</code> reference. A call to <code>std::forward&lt;T&gt;()</code> will instead <em>persist</em> the current value category of its argument, rather than allowing it to be blindly converted to an <code>lvalue</code> reference (this means that <code>rvalue</code>s will stay <code>rvalue</code>s and <code>lvalue</code>s will stay <code>lvalue</code>s).</p>
<p>As stated previously, the double ampersand <code>&amp;&amp;</code> has a special meaning in templates. <code>&amp;&amp;</code> usage in a template means the template should accept <em>either</em> <code>lvalue</code>s or <code>rvalue</code>s. This version of <code>&amp;&amp;</code> is colloqually known as a <a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">universal reference</a>. A universal reference is a way of telling the compiler that your template accepts <em>some</em> kind of reference as an argument, but it needs to deduce what the reference type actually is when the template is invoked.</p>
<p>When universal references are combined with <code>std::forward&lt;T&gt;()</code> you can write a template which can pass a reference without change to another function. Here's an example of forwarding an argument reference to an <code>std::string</code>'s assignment operator (which have different implementations for <code>rvalue</code>s and <code>lvalue</code>s!): </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename STRING&gt;</div>
<div class="line">void assign(std::string&amp; lhs, STRING&amp;&amp; rhs) {</div>
<div class="line">    // passes rhs to the assignment function as either an rvalue or lvalue depending on context</div>
<div class="line">    lhs = std::forward&lt;STRING&gt;(rhs); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void foo() {</div>
<div class="line">    std::string s;</div>
<div class="line">    std::string s2(&quot;foo&quot;);</div>
<div class="line">    assign(s, s2); // a deep copy is performed because s2 remains an lvalue</div>
<div class="line">    </div>
<div class="line">    // a swap is performed because the rvalue-ness created by std::move of is preserved inside assign()</div>
<div class="line">    assign(s, std::move(s2)); </div>
<div class="line">}</div>
</div><!-- fragment --><p>It should be noted that universal references also accept const references: </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, typename T2&gt;</div>
<div class="line">void assign(T&amp;&amp; lhs, T2&amp;&amp; rhs) {</div>
<div class="line">    lhs = std::forward&lt;T2&gt;(rhs);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::string s1 = &quot;foo&quot;;</div>
<div class="line">    std::string s2;</div>
<div class="line">    assign(s2, s1); // works!</div>
<div class="line">    assign(s2, (const)s1); // also works!</div>
<div class="line">    assign((const)s2, s1); // a compiler error, cannot assign a value to a const variable</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The takeaway here is that to write efficient template code for all usecases the author may need to incorporate universal references and forwarding. However, it is often <em>much</em> easier to write and maintain template code utilizing universal references and forwarding rather than be forced to write <code>lvalue</code> AND <code>rvalue</code> implementations of methods (where they are required).</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Universal References in Template Objects</h2>
<p>An important note here is that the universal reference treatment of the double ampersand <code>&amp;&amp;</code> <em>ONLY</em> takes place in top level templates. If you are writing a template <code>struct</code> or <code>class</code>, and you want to write a template method that uses universal references, you must add an additional <code>template</code> header to your method: </p><div class="fragment"><div class="line">template &lt;typename T&gt;</div>
<div class="line">struct my_struct {</div>
<div class="line">    void my_lvalue_assignment(T&amp; t) {</div>
<div class="line">        m_value = t;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    void my_rvalue_assignment(T&amp;&amp; t) {</div>
<div class="line">        m_value = std::move(t);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    template &lt;typename T2&gt;</div>
<div class="line">    void my_universal_reference_assignment(T2&amp;&amp; t2) {</div>
<div class="line">        m_value = std::forward&lt;T2&gt;(t2);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    T m_value;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is behavior may seem strange initially, but it has to do with what stage of compilation the code is being examined by the compiler. Once a template struct has been been constructed by the compiler (like if you wrote the statement <code>my_struct&lt;int&gt; ms;</code>), this forces the compiler to actually generate the final code for that struct (making <code>&amp;&amp;</code> represent <code>rvalue</code> references in calls to <code>my_rvalue_assignment()</code> because that's what the double ampersand means in non-template <code>c++</code> code!). The exception to this bevavior is in sub-templates (like in <code>my_universal_reference_assignment()</code>) which can be left un-generated by the compiler until they are actually called in the code.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Type Decay</h1>
<p>Type decay is the ability to take a template type and remove all references and const modifiers from it. This is useful when you are writing a template which which needs to accept a universal reference but will need to return the base form of that type. This can be done with <code>std::decay_t</code>, part of the <code>&lt;type_traits&gt;</code> standard library: </p><div class="fragment"><div class="line">#include &lt;utility&gt;</div>
<div class="line">#include &lt;type_traits&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">// std::decay_t&lt;T&gt; removes constness and references from type T</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">std::decay_t&lt;T&gt; add_three(T&amp;&amp; t) {</div>
<div class="line">    return t+3</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int a = 3;</div>
<div class="line">    const int b = 2;</div>
<div class="line">    std::cout &lt;&lt; add_three(a) &lt;&lt; std::endl; // returns `int`</div>
<div class="line">    std::cout &lt;&lt; add_three(b) &lt;&lt; std::endl; // still returns `int`, not `const int`</div>
<div class="line">    return 0; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">6</div>
<div class="line">5</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md22"></a>
Compiler Behavior with Templates and Inlining</h1>
<p><a href="https://en.cppreference.com/w/cpp/language/inline">Inlining in c++</a> is the language feature for writing code which can be "copy pasted" by the compiler wherever it is called in code instead of actually triggering a new function call on the stack. Inlining is a useful compiler technique because setting up new function calls on the stack during runtime has its own computation cost, in addition to the cost of actually <em>executing</em> the function.</p>
<p>Inlining is very similar to <a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html">macros in c</a>, with the distinction that inlining in <code>c++</code> is actually at the discretion of the compiler (the <code>inline</code> keyword is just a suggestion). Additionally, <code>inline</code> code is namespace aware, unlike macros which blindly paste text. There's also varous edgecases around efficiency and compilation which requires <code>inline</code> functions to be a true function on the stack rather than an effective text copy/paste, which the compiler will handle internally.</p>
<p>Inline functions and templates are very similar concepts. Their main distinction to the developer is that templates have the ability to be generated for different types (<code>std::string</code>, <code>int</code>, <code>my_object</code>, etc.), while inline functions are just normal functions with the <code>inline</code> keyword prepended to their definition: </p><div class="fragment"><div class="line">// compiler can choose to copy paste the function body logic into other functions</div>
<div class="line">inline int add(int a, int b) {</div>
<div class="line">    return a + b;</div>
<div class="line">}</div>
</div><!-- fragment --><p>There is another important trait shared by inline functions and templates, that they don't generate final code until they are called somewhere. As a consequence valid <code>c++</code> libraries can be written which are <em>header only</em> (no compiled <code>.cpp</code> files!). Header only <code>c++</code> libraries are very convenient, because they can be "installed" into a system as source code without pre-compiling them, similar to higher level languages like <code>python</code>.</p>
<p>In header somewhere: </p><div class="fragment"><div class="line">#ifndef MY_HEADER_ONLY_LIBRARY</div>
<div class="line">#define MY_HEADER_ONLY_LIBRARY</div>
<div class="line"> </div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">inline int real_main() {</div>
<div class="line">    std::cout &lt;&lt; &quot;hello from the real slim shady&quot; &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">#endif</div>
</div><!-- fragment --><p>In a <code>.cpp</code> somewhere: </p><div class="fragment"><div class="line">#include &quot;my_header_only_library.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    return real_main(); // real_main() is compiled because it is called here</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">hello from the real slim shady</div>
<div class="line">$</div>
</div><!-- fragment --><p>There are some limitations around writing code like this. For instance, header only libraries tend to produce larger binaries because the compiler copy pastes so much code (which also increases program start time as more data has to be loaded into memory to begin execution, even though execution may be faster once started). The fact that portions of a program are not pre-compiled also means that compilation speed can be slower as more code needs to be compiled every time. In the average case this is not going to be a problem when used in a project (remember, templates are used all the time by the standard library, see <code>std::string</code> which is a type alias to an underlying type <code>std::basic_string&lt;CharT&gt;</code> or <code>std::vector&lt;T&gt;</code>), but it is worth considering.</p>
<p>As a side note, <a href="https://en.cppreference.com/w/cpp/language/lambda">c++ lambdas</a> will also be inlined by the compiler where possible, making them very efficient by default.</p>
<p>It should be noted that if templates are required as part of a library's API, they are typically <em>required</em> to be implemented in a header, at least for any code where a type needs to be deduced by the user code's compiler.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Takeway</h2>
<p>For almost all developers, the best way to determine your usage of inlining and templates is <em>not</em> to consider the performance beforehand. Except cases where efficiency is a real bottleneck (and even there care must be taken to determine what, when, where and why the bottleneck is occurring), the main advantage to these tools is how much they improve the writability and readability of your code!</p>
<p>Being able to write libraries which don't require pre-compilation is very useful for distributing code to projects because it is both quicker and easier to install. Another advantage is you can write normal code alongside your templates allowing <em>all relevant</em> code to exist in the same file, rather than creating labyrinthine source and header dependencies and avoid populating your source with early function declarations just to get things to compile. The fact these libraries may add some startup overhead (reading slightly larger executable binary files from the disk) is unlikely to be the bottleneck to meet performance standards <em>in most cases</em>.</p>
<p>As a one wise man once said, "keep it simple stupid!" </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
