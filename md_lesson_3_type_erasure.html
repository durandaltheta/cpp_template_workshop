<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: Type Erasure</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Type Erasure </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md33"></a>
C Type Erasure</h1>
<p>A <code>void*</code> is a basic <code>c</code> pointer type which can represent any other type of pointer. This allows the passing of data between points in a program in a type agnostic fashion. This is called <a href="https://en.wikipedia.org/wiki/Type_erasure">type erasure</a>: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">print_string_from_void(void* str) {</div>
<div class="line">    // cast void* back to string </div>
<div class="line">    std::cout &lt;&lt; (const char*)str &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    const char* s = &quot;hello!&quot;;</div>
<div class="line">    void* v = (void*)s; // cast string to void*</div>
<div class="line">    print_string_from_void(v);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">hello!</div>
<div class="line">$</div>
</div><!-- fragment --><p>However, the above is not very useful if the code that handles the eventual <code>void*</code> doesn't know how to cast the pointer back to a known type. This problem is solved in one of two ways, with function pointers or with paired identifier values.</p>
<p>Function pointers are just what they sound like: pointers to a function. See subsection "Pointers to functions" in <a href="https://en.cppreference.com/w/cpp/language/pointer">this link</a> for details. It is possible to package a <code>void*</code> with function pointer which knows how to handle said <code>void*</code>: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">struct packaged_void_pointer {</div>
<div class="line">    void (*handler)(void*);</div>
<div class="line">    void* data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">print_string_from_void(void* str) {</div>
<div class="line">    // cast void* back to const char*</div>
<div class="line">    std::cout &lt;&lt; (const char*)str &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    packaged_void_pointer pvp{ print_string_from_void, &quot;hello&quot; };</div>
<div class="line">    pvp.handler(pvp.data);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">hello!</div>
<div class="line">$</div>
</div><!-- fragment --><p>Function pointers only handle the usecase where origin code knows what behavior needs to executed on a piece of data ahead of time. To interact with our <code>void*</code> in ways unknown to the sender of the data we can associate the <code>void*</code>'s original type with some other value so we can "decode" it on the other side.</p>
<p>This technique is often done with enumerations or strings as the associated identifier value: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">enum types {</div>
<div class="line">    is_unknown,</div>
<div class="line">    is_int,</div>
<div class="line">    is_string</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct void_pointer_with_id {</div>
<div class="line">    size_t id = types::is_unknown;</div>
<div class="line">    void* data = std::nullptr;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void print_void_pointer_with_id(void_pointer_with_id avp) {</div>
<div class="line">    switch(avd.id) {</div>
<div class="line">        case types::is_int:</div>
<div class="line">            std::cout &lt;&lt; &quot;void pointer is an int: &quot; &lt;&lt; *((int*)(wv.data)) &lt;&lt; std::endl;</div>
<div class="line">            break;</div>
<div class="line">        case types::is_string:</div>
<div class="line">            std::cout &lt;&lt; &quot;void pointer is a std::string: &quot; &lt;&lt; (const char*)(wv.data) &lt;&lt; std::endl;</div>
<div class="line">            break;</div>
<div class="line">        case types::is_unknown:</div>
<div class="line">        default:</div>
<div class="line">            std::cout &lt;&lt; &quot;void pointer is of an unknown type&quot; &lt;&lt; std::endl;</div>
<div class="line">            break;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int i = 3;</div>
<div class="line">    const char* s = &quot;foo&quot;</div>
<div class="line">    void_pointer_with_id avp;</div>
<div class="line"> </div>
<div class="line">    print_void_pointer_with_id(avp);</div>
<div class="line"> </div>
<div class="line">    avp.id = types::is_int;</div>
<div class="line">    avp.data = &amp;i;</div>
<div class="line">    print_void_pointer_with_id(avp);</div>
<div class="line"> </div>
<div class="line">    avp.id = types::is_string;</div>
<div class="line">    avp.data = s;</div>
<div class="line">    print_void_pointer_with_id(avp);</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">void pointer is of an unknown types</div>
<div class="line">void pointer is an int: 3</div>
<div class="line">void pointer is a std::string: foo</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md34"></a>
C++ Templated Type Erasure</h1>
<p>Clever combination of templates with <code>void*</code> allows for safer and easier type erasure. For instance, <a href="https://en.cppreference.com/w/cpp/types/type_info">std::type_info</a> is a convenient standard library utility type which allows us to compare types, allowing for compiler enforced type safety. An <code>std::type_info</code> object for a given type can be acquired with the <code>c++</code> expression <code>typeid(my_type_or_variable_here)</code>: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">void compare_type_info(const std::type_info&amp; lhs, const std::type_info&amp; rhs) {</div>
<div class="line">    if(lhs == rhs) {</div>
<div class="line">        std::cout &lt;&lt; &quot;lhs type matches rhs type&quot; &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    } else {</div>
<div class="line">        std::cout &lt;&lt; &quot;lhs type does not match rhs type&quot; &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int i = 0;</div>
<div class="line">    const char* s = &quot;foo&quot;;</div>
<div class="line"> </div>
<div class="line">    compare_type_info(typeid(i), typeid(int));</div>
<div class="line">    compare_type_info(typeid(i), typeid(s));</div>
<div class="line">    compare_type_info(typeid(s), typeid(&quot;faa&quot;));</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">lhs type matches rhs type</div>
<div class="line">lhs type does not match rhs type</div>
<div class="line">lhs type matches rhs type</div>
<div class="line">$</div>
</div><!-- fragment --><p>It should be noted that the above technique is only safe when used on values that are part of the same program, you cannot safely use this technique when sending values via inter-process mechanims.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
std::type_info particularities</h2>
<p>Some things about <code>std::type_info</code> are unusual. For one, the function <code>std::type_info::hash_code()</code> sounds like it to return a unique value, but it does not, it only returns a value that is guaranteed to be the same as another <code>std::type_info</code> which represents the same type. Instead, direct comparison of <code>std::type_info</code> objects via <code>==</code> is required to determine if types are identical.</p>
<p>In addition to this, we cannot take a copy of the <code>std::type_info</code> object because construction and assignment operations are explicitly deleted, so we can only get a reference to it via <code>typeid()</code>. According to <a href="https://en.cppreference.com/w/cpp/language/typeid">cppreference</a>: </p><blockquote class="doxtable">
<p>The typeid expression is an lvalue expression which refers to an object with static storage duration, of const-qualified version of the polymorphic type std::type_info or some type derived from it. </p>
</blockquote>
<p>This means that we can take a <code>const std::type_info*</code> pointer of the result of a <code>typeid()</code> expression and use that pointer at some arbitrary time and place in the future. As an example, another related standard library type utility, <a href="https://en.cppreference.com/w/cpp/types/type_index">std::type_index</a>, whose documentation here explicitly mentions that its constructor maintains a <em>pointer</em> to a given <code>type_info</code> object.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Using std::type_info in templates</h1>
<p>With templates and <code>std::type_info</code> we can improve the process of type erasure, because is possible to write an object which "wraps" a value of any type using template functions and then can use further templates to unwrap it at runtime: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">// A struct which can hold a pointer to any value</div>
<div class="line">struct wrapped_value {</div>
<div class="line">    // assign a value to this value wrapper</div>
<div class="line">    template &lt;typename T&gt;</div>
<div class="line">    void set(T&amp; t) {</div>
<div class="line">        ptr = &amp;t;</div>
<div class="line">        tip = &amp;typeid(typename std::decay&lt;T&gt;);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // if a value is assigned and the value type matches `T` return `true`, else return `false`</div>
<div class="line">    template &lt;typename T&gt;</div>
<div class="line">    bool is() {</div>
<div class="line">        return ptr != nullptr &amp;&amp; *tip == typeid(typename std::decay&lt;T&gt;);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // return a reference to the assigned value by casting and dereferencing the void*</div>
<div class="line">    template &lt;typename T&gt;</div>
<div class="line">    T&amp; to() {</div>
<div class="line">        return *(static_cast&lt;T*&gt;(ptr));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    void* ptr = nullptr;</div>
<div class="line">    const std::type_info* tip;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void print_wrapped_value(wrapped_value wv) {</div>
<div class="line">    if(wv.is&lt;int&gt;()) {</div>
<div class="line">        std::cout &lt;&lt; &quot;wrapped value is an int: &quot; &lt;&lt; wv.to&lt;std::string&gt;() &lt;&lt; std::endl;</div>
<div class="line">    } else if(wv.is&lt;std::string&gt;()) {</div>
<div class="line">        std::cout &lt;&lt; &quot;wrapped value is a std::string: &quot; &lt;&lt; wv.to&lt;std::string&gt;() &lt;&lt; std::endl;</div>
<div class="line">    } else {</div>
<div class="line">        std::cout &lt;&lt; &quot;wrapped value is of an unknown type&quot; &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    bool b = true;</div>
<div class="line">    int i = 3;</div>
<div class="line">    std::string s = &quot;foo&quot;;</div>
<div class="line">    wrapped_value wv;</div>
<div class="line"> </div>
<div class="line">    wv.assign(b);</div>
<div class="line">    print_wrapped_value(wv);</div>
<div class="line">    wv.assign(i);</div>
<div class="line">    print_wrapped_value(wv);</div>
<div class="line">    wv.assign(s);</div>
<div class="line">    print_wrapped_value(wv);</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">wrapped value is of an unknown types</div>
<div class="line">wrapped value is an int: 3</div>
<div class="line">wrapped value is a std::string: foo</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
std::any</h1>
<p><a href="https://en.cppreference.com/w/cpp/utility/any">std::any</a> is a <code>c++17</code> object which can store any type using type erasure. Some of the techniques shown above are possibly how the <code>c++17</code> object <code>std::any</code> internally encapsulates its data. However, <code>std::any</code> extends the above functionality by implementing enforced type checking via <code>std::bad_any_cast</code> exception throws. <code>std::any</code> can also store an actual value (not just a pointer to a value) and properly destroy said value when the <code>std::any</code> goes out of scope, as necessary. I will leave it to the reader to guess at or research how this is done (hint: function pointers to destructors are involved, and potentially heap allocation but not always). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
