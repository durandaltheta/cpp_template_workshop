<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: Callables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Callables </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md37"></a>
What is a Callable?</h1>
<p>According to <a href="https://en.cppreference.com/w/cpp/named_req/Callable">cppreference</a> a Callable is: </p><blockquote class="doxtable">
<p>A Callable type is a type for which the INVOKE and INVOKE&lt;R&gt; operations (used by, e.g., <code>std::function</code>, <code>std::bind</code>, and <code>std::thread::thread</code>) are applicable. </p>
</blockquote>
<p>What this means is if you can "execute" anything with <code>()</code> (internally the compiler transforms this to an <code>INVOKE</code> or <code>INVOKE&lt;R&gt;</code>) in a similar fashion to calling a normal function, then that object, function, or lambda is a <code>Callable</code>.</p>
<p>Examples: </p><div class="fragment"><div class="line">#include &lt;functional&gt;</div>
<div class="line"> </div>
<div class="line">int f() { // function f is a Callable</div>
<div class="line">    return 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct s { </div>
<div class="line">    // struct s is a Callable because it has an operator() overload. This type </div>
<div class="line">    // of object is also known as a Functor.</div>
<div class="line">    int operator()() { </div>
<div class="line">        return 2;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int (*fptr)() = f; // function pointer fptr is a Callable </div>
<div class="line">    auto l = []{ return 3; }; // lambda l is a Callable </div>
<div class="line">    std::function&lt;int()&gt; w(l); // function wrapper w is a Callable</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md38"></a>
Callables and templates</h1>
<p>Because of SFINAE it is possible to write generic templates which accept Callables as an argument, allowing a broad range of possible argument types: </p><div class="fragment"><div class="line">int f() { // function f is a Callable</div>
<div class="line">    return 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct s { </div>
<div class="line">    int operator()() { </div>
<div class="line">        return 2;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">template &lt;typename F&gt;</div>
<div class="line">int execute_callable(F&amp;&amp; f) {</div>
<div class="line">    f();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    struct s;</div>
<div class="line">    int (*fptr)() = f; </div>
<div class="line">    auto l = []{ return 3; }; </div>
<div class="line">    std::function&lt;int()&gt; w(l); </div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; execute_callable(f) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable(s) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable(fptr) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable(l) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable(w) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">1</div>
<div class="line">2</div>
<div class="line">1</div>
<div class="line">3</div>
<div class="line">3</div>
<div class="line">$</div>
</div><!-- fragment --><p>A function which accepts another function is known as a <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher order function</a>. Higher order functions are very powerful tools (especially when written as templates!) for encapsulating executable behavior. For instance, a library function can be written that accepts a user Callable as an argument that the library function promises to call when certain conditions are met (a callback). With templated Callables said API can be very flexible instead of rigorously strict.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Callable arguments</h1>
<p>SFINAE also allows the ability to pass arguments to an argument function: </p><div class="fragment"><div class="line">int foo(int i) {</div>
<div class="line">    return i + 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct s {</div>
<div class="line">    int operator()(int i) {</div>
<div class="line">        return i + 2;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename F&gt;</div>
<div class="line">int execute_callable(F&amp;&amp; f, int i) {</div>
<div class="line">    return f(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto l = [](int i){ return i + 3; };</div>
<div class="line">    std::cout &lt;&lt; execute_callable(foo, 10) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable(s(), 10) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable(l, 10) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">11</div>
<div class="line">12</div>
<div class="line">13</div>
<div class="line">$</div>
</div><!-- fragment --><p>There are no standard defined limits on the number or types of arguments that are passable to Callables. In fact, the standard library provides a very commonly used template which allows for any number of potential arguments, <a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a>:</p>
<div class="fragment"><div class="line">#include &lt;thread&gt;</div>
<div class="line"> </div>
<div class="line">void foo(int i) {</div>
<div class="line">   std::cout &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct s {</div>
<div class="line">    void operator()(std::string s) {</div>
<div class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    auto l = [](std::string s, int i) { std::cout &lt;&lt; s + std::to_string(i) &lt;&lt; std::endl; };</div>
<div class="line"> </div>
<div class="line">    std::thread th0(foo, 15);</div>
<div class="line">    th0.join();</div>
<div class="line"> </div>
<div class="line">    std::thread th1(s(), &quot;hello world&quot;);</div>
<div class="line">    th1.join();</div>
<div class="line"> </div>
<div class="line">    std::thread th2(l, &quot;this is a number: &quot;, 7);</div>
<div class="line">    th2.join();</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">15</div>
<div class="line">hello world</div>
<div class="line">this is a number: 7</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md40"></a>
Wrapping Callables as finalized types</h1>
<p>When a defined type is needed, user Callables can be wrapped inside the <a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function polymorphic function wrapper</a>. <code>std::function</code> instances use a templating technique called <a href="https://en.wikipedia.org/wiki/Type_erasure">type erasure</a> to remove the <em>actual</em> type from being visible to the holder of an <code>std::function</code> so that only the <code>std::function</code> itself knows what it truly contains.</p>
<p><code>std::function</code>s are defined with the return value and argument types inside of the template <code>&lt;&gt;</code> brackets following the pattern <code>std::function&lt;ReturnType(Arg1Type, Arg2Type, ..., ArgNType)&gt;</code>: </p><div class="fragment"><div class="line">#include &lt;functional&gt;</div>
<div class="line"> </div>
<div class="line">int foo(int i) {</div>
<div class="line">    return i + 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct s {</div>
<div class="line">    int operator()(int i) {</div>
<div class="line">        return i + 2;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::function&lt;int(int)&gt; w;</div>
<div class="line"> </div>
<div class="line">    w = foo;</div>
<div class="line">    std::cout &lt;&lt; w(1) &lt;&lt; std::endl;</div>
<div class="line">    w = s();</div>
<div class="line">    std::cout &lt;&lt; w(1) &lt;&lt; std::endl;</div>
<div class="line">    w = [](int i){ return i + 3; };</div>
<div class="line">    std::cout &lt;&lt; w(1) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">2</div>
<div class="line">3</div>
<div class="line">4</div>
<div class="line">$</div>
</div><!-- fragment --><p>A wrapper like <code>std::function</code> is often necessary when writing parts of code which <em>need</em> to be precompiled (IE, code which is not header only). Combining the concepts of template Callables with <code>std::function</code> allows for all kinds of interesting code.</p>
<h1><a class="anchor" id="autotoc_md41"></a>
Examining lambdas</h1>
<p>Lambdas are a type of callable introduced in <code>c++11</code> that I've found both extremely useful and often ill-understood by developers generally. To address this deficit of knowledge I have written this optional <a class="el" href="md_lambda_primer.html">lambda primer</a> as an educational aid for anyone who wants to know more about them.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Algorithms and Callables</h1>
<p>It is possible to write data processing algorithms which incorporate user provided Callables to provide a portion of the implementation. An example of this in the standard library is <a href="https://en.cppreference.com/w/cpp/algorithm/transform">std::transform</a>, which accepts a start <code>cur</code> iterator, an <code>end</code> iterator, an output <code>out</code> iterator, and a Callable. <code>std::transform</code> will iterate from <code>cur</code> to <code>end</code>, callng the Callable with the value pointed to by <code>cur</code> and storing the result in the <code>out</code> iterator. An implemenation of said algorithm might look like: </p><div class="fragment"><div class="line">namespace std {</div>
<div class="line"> </div>
<div class="line">template &lt;typename InputIt, typename OutputIt, typename UnaryOperation&gt;</div>
<div class="line">void transform(InputIt cur, InputIt end, OutputIt out, UnaryOperation f) {</div>
<div class="line">    while(cur != end) {</div>
<div class="line">        *out = f(*cur);</div>
<div class="line">        ++cur;</div>
<div class="line">        ++out;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>The above <code>UnaryOperation</code> is any Callable which accepts the type stored in the input iterators and whose output can be stored in the output iterator: </p><div class="fragment"><div class="line">#include &lt;algorithm&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">int add_2(int i) {</div>
<div class="line">    return i + 2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct add_1 {</div>
<div class="line">    unsigned int operator()(int i) {</div>
<div class="line">        return i + 1;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    const std::vector&lt;int&gt; inp{1,2,3};</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;int&gt; out(inp.size());</div>
<div class="line">        std::transform(inp.begin(), inp.end(), out.begin(), add_2);</div>
<div class="line"> </div>
<div class="line">        for(auto&amp; e : out) {</div>
<div class="line">            std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;size_t&gt; out(inp.size());</div>
<div class="line">        std::transform(inp.begin(), inp.end(), out.begin(), add_1());</div>
<div class="line"> </div>
<div class="line">        for(auto&amp; e : out) {</div>
<div class="line">            std::cout &lt;&lt; &quot;unsigned int: &quot; &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;std::string&gt; out(inp.size());</div>
<div class="line"> </div>
<div class="line">        auto add_1_and_to_string = [](int i) {</div>
<div class="line">            return std::to_string(i + 1);</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        std::transform(inp.begin(), inp.end(), out.begin(), add_1_and_to_string);</div>
<div class="line"> </div>
<div class="line">        for(auto&amp; e : out) {</div>
<div class="line">            std::cout &lt;&lt; &quot;string: &quot; &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">int: 3</div>
<div class="line">int: 4</div>
<div class="line">int: 5</div>
<div class="line">unsigned int: 2</div>
<div class="line">unsigned int: 3</div>
<div class="line">unsigned int: 4</div>
<div class="line">string: 2</div>
<div class="line">string: 3</div>
<div class="line">string: 4</div>
<div class="line">$</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
