<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: Substitution Failure Is Not An Error - SFINAE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Substitution Failure Is Not An Error - SFINAE </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The phrase "substitution failure is not an error" is a phrase coined by David Vandevoorde. It refers to the behavior of the compiler when processing templates. In essence: if an error occurs when the compiler is checking whether a template can return valid code it does <em>not</em> halt compilation and return an error. Instead it first checks the remaining available template candidates for an alternative which <em>is</em> valid. Only if no template is found which can produce valid code does the compiler error out.</p>
<p>This behavior is useful because it lets the user write multiple specialized templates to address different types. An example of this was provided in the first lesson: </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, typename T2&gt;</div>
<div class="line">T add(T t1, T2 t2) {</div>
<div class="line">    return t1 + t2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">std::string add(std::string s, T t) {</div>
<div class="line">    return s + std::to_string(t);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">std::string add(T t, std::string s) {</div>
<div class="line">    return std::to_string(t) + s;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add(std::string(&quot;number: &quot;, 3.0) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add(3, std::string(&quot;is also a number &quot;) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">3</div>
<div class="line">number: 3.0</div>
<div class="line">3 is also a number</div>
<div class="line">$</div>
</div><!-- fragment --><p>As can be seen above, aside from the body of the functions, the templates for <code>add</code> are different in one of the following ways:</p><ul>
<li>they have different <code>template</code> headers AND/OR</li>
<li>they have different function signatures (the order/types of their arguments are unique)</li>
</ul>
<p>Writing multiple versions of templates in this way is the simplest way to create special case handling. In certain cases this allows other users to write their <em>own</em> template specializations building on the ones written before. An example of this can be seen in global operator overloads: </p><div class="fragment"><div class="line">struct MyClass {</div>
<div class="line">    MyClass(int i) : m_i(i) { }</div>
<div class="line"> </div>
<div class="line">    template &lt;typename T&gt;</div>
<div class="line">    int operator+(T&amp;&amp; rhs) {</div>
<div class="line">        // allow compiler to select the appropriate addition function for adding to an int</div>
<div class="line">        return m_i + rhs; </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    const int m_i;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// globally overloading the &#39;+&#39; operator in the case where MyClass is on the right hand side of the operation</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">int operator+(T&amp;&amp; lhs, MyClass rhs) {</div>
<div class="line">    // use MyClass&#39;s internal standard addition operator</div>
<div class="line">    return rhs + lhs; </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md39"></a>
SFINAE template selection</h1>
<p>Compiler selection between competing templates in C++ is a bit stranger than you'd expect. When I first started studying this topic I assumed the "first valid definition" the compiler came across to be selected, to match behavior in other parts of the <code>C</code> programming language, like linking after compilation (if multiple identical function definitions are provided to the linker, the first valid one the linker comes across will be selected and the others discarded).</p>
<p>Instead, <a href="https://stackoverflow.com/questions/15497004/c-template-selection">as described in this answer</a> when the compiler has several valid template candidates available it selects the one that is <em>most specific</em>.</p>
<p>A template which is <em>more</em> specific, can be used in <em>fewer</em> circumstances.</p>
<p>This means that templates with more deduced types (like <code>typename T, typename T2, ..., typename TN</code>) in it's <code>template &lt; &gt;</code> header the <em>less specialized</em> (and more generalized) the template is.</p>
<p>Given the previously defined <code>add()</code> template function signatures: </p><div class="fragment"><div class="line">template &lt;typename T, typename T2&gt; // informally naming this &quot;template 1&quot;, it is the *least* specialized</div>
<div class="line">T add(T t1, T2 t2);</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">std::string add(std::string s, T t); // this is &quot;template 2&quot;, a little more specialized because it has only one deduced type `T`</div>
<div class="line"> </div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">std::string add(T t, std::string s); // &quot;template 3&quot; is similar to template 2 but different arguments are deduced</div>
</div><!-- fragment --><p>Template 1 is the least specialized, because the compiler has to deduce two types <code>T</code> and <code>T2</code> rather than a single type or less. Template 2 and 3 are equally specialized from that perspective and will be selected by the compiler whenever it can.</p>
<div class="fragment"><div class="line">add(1,2); // template 1 selected </div>
<div class="line">add(3,std::string(foo)); // template 3 selected</div>
<div class="line">add(std::string(faa),17); // template 2 selected</div>
</div><!-- fragment --><p>However, which one would the compiler think is the most specialized in a scenario where both arguents <code>a1</code> and <code>a2</code> are <code>std::string</code>s?: </p><div class="fragment"><div class="line">std::cout &lt;&lt; add(std::string(&quot;hello &quot;), std::string(&quot;world!&quot;)) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>I have not found any documentation on this case. However, in my case the compiler will error because the <code>error: call of overloaded ‘add(std::string, std::string)’ is ambiguous</code>.</p>
<p>Instead we can remove ambiguity by creating a non-template, overloaded definition of our function, where <em>no</em> types are deduced by the compiler: </p><div class="fragment"><div class="line">// no template header here, as this is a full function definition</div>
<div class="line">// this function is most specialized and will be selected when `add()`ing two `std::string`s</div>
<div class="line">std::string add(std::string s, std::string s2) {</div>
<div class="line">    std::cout &lt;&lt; &quot;ADD 4&quot; &lt;&lt; std::endl;</div>
<div class="line">    return s + s2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>With this additional definition, the 4th version of <code>add()</code> would be selected when <code>add()</code>ing two <code>std::string</code> arguments: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;my_add_template_header.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; add(std::string(&quot;hello &quot;), std::string(&quot;world!&quot;)) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out</div>
<div class="line">ADD 4</div>
<div class="line">$</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
Full Template Specialization</h2>
<p>There is a concept in <code>c++</code> called <a href="https://en.cppreference.com/w/cpp/language/template_specialization">full template specialization</a> that is very similar to writing a fully specified non-template version of a function. In practice, a full specialization <em>is</em> a fully specified non-template version of a function (just like <code>std::string add(std::string, std::string)</code> in the previous section), but it does it in a different way.</p>
<p>Instead of simply writing a new template definition, template specializations write versions of <code>template</code> code with the template <code>&lt;&gt;</code> types hard coded: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, typename T2&gt; // this is the primary template the specializations refer to</div>
<div class="line">auto // auto keyword can be used to allow the return type to be deduced</div>
<div class="line">add(T&amp;&amp; t, T2&amp;&amp; t2) {</div>
<div class="line">    std::cout &lt;&lt; &quot;add(T1,T2)&quot; &lt;&lt; std::endl;</div>
<div class="line">    return t + t2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;&gt; // This is still a template! Brackets are empty because we are going to hardcode them!</div>
<div class="line">int add&lt;int,int&gt;(int i, int i2) {</div>
<div class="line">    std::cout &lt;&lt; &quot;add(int,int)&quot; &lt;&lt; std::endl;</div>
<div class="line">    return i + i2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;&gt; </div>
<div class="line">double add&lt;double,double&gt;(double i, double i2) {</div>
<div class="line">    std::cout &lt;&lt; &quot;add(double,double)&quot; &lt;&lt; std::endl;</div>
<div class="line">    return i + i2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; add(1,2) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add(3.0,4.0) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; add(3.0,7) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">add(int,int)</div>
<div class="line">3</div>
<div class="line">add(double,double)</div>
<div class="line">7.0</div>
<div class="line">add(T1,T2)</div>
<div class="line">10 </div>
<div class="line">$</div>
</div><!-- fragment --><p>Explicit/full template specialization is a complicated topic which is not very useful most of the time, so I will leave further exploration of this topic to the reader.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
Template and Overload Selection</h2>
<p>It should be noted that when all other template rules are accounted for, the compiler follows <a href="https://en.cppreference.com/w/cpp/language/overload_resolution">overload resolution rules</a>, such as when dealing with versions of functions accepting objects with different positions in an inheritence tree. For instance: </p><div class="fragment"><div class="line">#include &lt;string&gt; </div>
<div class="line"> </div>
<div class="line">class MyString : std::string {</div>
<div class="line">    // just inherit and use everything from parent std::string as-is</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyString add(MyString s1, Mystring s2) { // this is just as specialized as &#39;std::string add(std::string,std::string)&#39;</div>
<div class="line">    return s1 + s2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the above scenario, because MyString can be cast to a it's parent type <code>std::string</code>, the above implementation of <code>Mystring add(MyString s1, Mystring s2)</code> is probably unnecessary. However, it will probably be selected by the compiler over <code>std::string add(std::string,std::string)</code> should said function be defined.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
SFINAE challenge</h1>
<p>Before heading into the unit tests, consider studying the <a class="el" href="md_sfinae_challenge_section.html">sfinae challenge section</a>. This section covers "method detection", an sfinae example too complicated to be required by this course. HOWEVER, it is a very useful example because of the challenge it presents, so take it as an opportunity to <em>really grok</em> some of the concepts presented in this lesson. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
