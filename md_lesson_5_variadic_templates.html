<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple thread: Variadic Templates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple thread
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Variadic Templates </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md38"></a>
What does variadic mean?</h1>
<p>In classic <code>c</code> a <a href="https://en.cppreference.com/w/cpp/utility/variadic">variadic function</a> is a function which takes a variable number of arguments.</p>
<p>Classic <code>c</code> variadic functions have several limitations. The first is that they aren't templated, but hard-coded, limiting their flexibility when dealing with arbitrary types. The second is that variadic functions operate on raw pointers, which is less ideal than references. The third is that they are evaluated at runtime rather than compile time, preventing the compiler from inlining operations.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Parameter packs</h1>
<p><code>c++11</code> expanded upon the concept of classic variadic functions by introducing a <em>very</em> powerful feature called <a href="https://en.cppreference.com/w/cpp/language/parameter_pack">parameter packs</a> which enable the writing of templates with variable number of arguments.</p>
<p>A parameter pack uses 3 periods <code>...</code> to distinguish itself from standard template types. A template type can be defined which can represent a variable number of templated types by using the keyword <code>typename...</code>: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
</div><!-- fragment --><p>When using a parameter pack in a function signature the <code>...</code> is placed after the type and before the argument name which will represent the parameter pack: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
<div class="line">void foo(As... as) { // parameter pack of type &#39;As&#39; is named &#39;as&#39; </div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>References and universal references can be used: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
<div class="line">void foo(As&amp;&amp;... as) { // parameter pack &#39;as&#39; are references</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>A parameter pack can be used similarly to other arguments, except that <code>...</code> should be postpended to the end to inform the compiler to repeat any operation done on all arguments it represents: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
<div class="line">void wrap_printf(As... as) { // &#39;as...&#39; resolves to &#39;const char*, const char*&#39;</div>
<div class="line">    printf(as...); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    wrap_printf(&quot;hello %s\n&quot;, &quot;world&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">hello world</div>
<div class="line">$</div>
</div><!-- fragment --><p>Parameter packs can be forwarded/moved as normal: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
<div class="line">void foo(As&amp;&amp;... as) { // parameter pack &#39;as&#39; are references </div>
<div class="line">    // each reference represented by &#39;as&#39; is individually forwarded to &#39;faa()&#39;</div>
<div class="line">    faa(std::forward&lt;As&gt;(as)...); </div>
<div class="line">}</div>
</div><!-- fragment --><p>If a template uses a normal <code>template</code> <code>typename</code> as well as a parameter pack <code>typename...</code> then the parameter pack should typically come last: </p><div class="fragment"><div class="line">template &lt;typneame A, typename... As&gt;</div>
<div class="line">void faa(A&amp;&amp; a, As&amp;&amp;... as) {</div>
<div class="line">    // can use a and as... as normal</div>
<div class="line">}</div>
</div><!-- fragment --><p>To be specific, putting the <code>typename...</code> last is a requirement for class templates, but for function templates, parameter packs can appear anywhere.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Processing parameter pack elements with recursive templates</h1>
<p>In the ideal case the developer will not have to process the individual elements of a parameter pack, because the <code>as...</code> variable will resolve to the actual arguments that the compiler can understand.</p>
<p>However, sometimes you run into situations where the template itself needs to process through the arguments in a parameter pack. A common pattern to deal with parameter pack iteration is to write templates so they process one argument at a time in a recursive fashion. As a reminder, recursion is a programming technique where a function calls itself instead of using a loop construct: </p><div class="fragment"><div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">// sum_vector recursively calls itself</div>
<div class="line">int sum_vector(int cur, std::vector&lt;int&gt;::iterator it, std::vector&lt;int&gt;::iterator end) {</div>
<div class="line">    if(it != end) {</div>
<div class="line">        return sum_vector(sum + *it, ++it, end);</div>
<div class="line">    } else {</div>
<div class="line">        return cur;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; v{1,5,17,3};</div>
<div class="line">    std::cout &lt;&lt; sum_vector(0, v.begin(), v.end()) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">26</div>
<div class="line">$</div>
</div><!-- fragment --><p>Variadic template arguments are often processed in a similar fashion, handling one concrete argument at a time. They break out of recursion by writing an overloaded template or function with the same function name that does not recursively call itself: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">// final function when no arguments are left to process</div>
<div class="line">void print() { </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// handle one argument at a time</div>
<div class="line">template &lt;typename A, typename... As&gt;</div>
<div class="line">void print(A&amp;&amp; a, As&amp;&amp;... as) {</div>
<div class="line">    std::cout &lt;&lt; std::forward&lt;A&gt;(a); // process one argument</div>
<div class="line">    print(std::forward&lt;As&gt;(as)...); // pass the rest to another print call</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    print(&quot;hello&quot;, &quot; &quot;, &quot;world&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">hello world</div>
<div class="line">$</div>
</div><!-- fragment --><p>The compiler actually writes a function definition to handle every generated usage of a template. The naive generated code from the above templates might look something like: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">void print() {</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void print(const char* a) {</div>
<div class="line">    std::cout &lt;&lt; a;</div>
<div class="line">    print();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void print(const char* a, const char* b) {</div>
<div class="line">    std::cout &lt;&lt; a;</div>
<div class="line">    print(b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void print(const char* a, const char* b, const char* c) {</div>
<div class="line">    std::cout &lt;&lt; a;</div>
<div class="line">    print(b, c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    print(&quot;hello&quot;, &quot; &quot;, &quot;world&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, in reality the compiler will probably inline much of the above to be something more like: </p><div class="fragment"><div class="line">include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; &quot;hello&quot;;</div>
<div class="line">    std::cout &lt;&lt; &quot; &quot;;</div>
<div class="line">    std::cout &lt;&lt; &quot;world&quot;;</div>
<div class="line">    std::cout &lt;&lt; endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md41"></a>
Callables and parameter packs</h1>
<p>Callables can be easily combined with parameter packs to pass arbitrary number of arguments to them: </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename F, typename... As&gt; // declare a template parameter pack </div>
<div class="line">auto // allow the compiler to deduce the return type </div>
<div class="line">execute_callable_with_args(F&amp;&amp; f, As&amp;&amp;... as) {</div>
<div class="line">    return f(std::forward&lt;As&gt;(as)...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int foo() {</div>
<div class="line">    return 3;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int faa(int i, int i2, int i3) {</div>
<div class="line">    return i + i2 + i3;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct s {</div>
<div class="line">    std::string operator()(std::string s, std::string s2) {</div>
<div class="line">        return s + s2;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; execute_callable_with_args(foo) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable_with_args(faa, 1, 2, 3) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable_with_args(s(), &quot;hello&quot;, &quot; world&quot;) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">3</div>
<div class="line">6</div>
<div class="line">hello world</div>
<div class="line">$</div>
</div><!-- fragment --><p>The above pattern allows for very flexible algorithm construction.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Iterator group advancement</h1>
<p>One pattern that is useful in advanced algorithms is the ability to iterate over multiple containers simultaneously. This can be done simply via parameter packs and recursive template calls (which will be trivially inlined): </p><div class="fragment"><div class="line">// explicitly accept iterators as references</div>
<div class="line">template &lt;typename IT&gt;</div>
<div class="line">void advance_group(IT&amp; it) { // process the final iterator</div>
<div class="line">    ++it; // advance the iterator by reference</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename IT, typename IT2, typename... ITs&gt;</div>
<div class="line">void advance_group(IT&amp; it, IT2&amp; it2, ITs&amp;... its) {</div>
<div class="line">    ++it; // advance the iterator by reference</div>
<div class="line">    advance_group(it2, its...); // advance the remaining iterators</div>
<div class="line">}</div>
</div><!-- fragment --><p>This allows for the creation of algorithms which execute a Callable on any number of container elements: </p><div class="fragment"><div class="line">namespace detail {</div>
<div class="line"> </div>
<div class="line">template &lt;typename F, typename IT, typename... ITs&gt;</div>
<div class="line">void each(F&amp;&amp; f, IT&amp;&amp; it, IT&amp;&amp; it_end, ITs&amp;&amp;... its) {</div>
<div class="line">    while(it != it_end) { // while we haven&#39;t reached the end of the current container</div>
<div class="line">        f(*it, *its...); // f is executed with the current element in each container</div>
<div class="line">        advance_group(it, its...); // advance the iterators</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>We can use another template to abstract the usage of iterators: </p><div class="fragment"><div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">// include our detail::each </div>
<div class="line"> </div>
<div class="line">template &lt;typename F, typename C, typename... Cs&gt;</div>
<div class="line">void</div>
<div class="line">each(F&amp;&amp; f, C&amp;&amp; c, Cs&amp;&amp;... cs) {</div>
<div class="line">    detail::each(f, c.begin(), c.end(), cs.begin()...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; v1{1,2,3};</div>
<div class="line">    std::vector&lt;int&gt; v2{4,5,6};</div>
<div class="line">    std::vector&lt;int&gt; out;</div>
<div class="line"> </div>
<div class="line">    auto add = [&amp;out](int a, int b){ out.push_back(a + b); };</div>
<div class="line">    each(add, v1, v2);</div>
<div class="line"> </div>
<div class="line">    for(auto&amp; e : out) {</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">5</div>
<div class="line">7</div>
<div class="line">9</div>
<div class="line">$</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
