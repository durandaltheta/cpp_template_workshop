<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: Variadic Templates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Variadic Templates </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md38"></a>
What does variadic mean?</h1>
<p>In classic <code>c</code> a <a href="https://en.cppreference.com/w/cpp/utility/variadic">variadic function</a> is a function which takes a variable number of arguments.</p>
<p>Classic <code>c</code> variadic functions have several limitations. The first is that they aren't templated, but hard-coded, limiting their flexibility when dealing with arbitrary types. The second is that variadic functions operate on raw pointers, which is less ideal than references. The third is that they are evaluated at runtime rather than compile time, preventing the compiler from inlining operations.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Parameter packs</h1>
<p><code>c++11</code> expanded upon the concept of classic variadic functions by introducing a <em>very</em> powerful feature called <a href="https://en.cppreference.com/w/cpp/language/parameter_pack">parameter packs</a> which enable the writing of templates with variable number of arguments.</p>
<p>A parameter pack uses 3 periods <code>...</code> to distinguish itself from standard template types. A template type can be defined which can represent a variable number of templated types by using the keyword <code>typename...</code>: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
</div><!-- fragment --><p>When using a parameter pack in a function signature the <code>...</code> is placed after the type and before the argument name which will represent the parameter pack: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
<div class="line">void foo(As... as) { // parameter pack of type &#39;As&#39; is named &#39;as&#39; </div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>References and universal references can be used: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
<div class="line">void foo(As&amp;&amp;... as) { // parameter pack &#39;as&#39; are references</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>A parameter pack can be used similarly to other arguments, except that <code>...</code> should be postpended to the end to inform the compiler to repeat any operation done on all arguments it represents: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
<div class="line">void wrap_printf(As... as) { // &#39;as...&#39; resolves to &#39;const char*, const char*&#39;</div>
<div class="line">    printf(as...); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    wrap_printf(&quot;hello %s\n&quot;, &quot;world&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">hello world</div>
<div class="line">$</div>
</div><!-- fragment --><p>Parameter packs can be forwarded/moved as normal: </p><div class="fragment"><div class="line">template &lt;typename... As&gt;</div>
<div class="line">void foo(As&amp;&amp;... as) { // parameter pack &#39;as&#39; are references </div>
<div class="line">    // each reference represented by &#39;as&#39; is individually forwarded to &#39;faa()&#39;</div>
<div class="line">    faa(std::forward&lt;As&gt;(as)...); </div>
<div class="line">}</div>
</div><!-- fragment --><p>If a template uses a normal <code>template</code> <code>typename</code> as well as a parameter pack <code>typename...</code> then the parameter pack should typically come last: </p><div class="fragment"><div class="line">template &lt;typneame A, typename... As&gt;</div>
<div class="line">void faa(A&amp;&amp; a, As&amp;&amp;... as) {</div>
<div class="line">    // can use a and as... as normal</div>
<div class="line">}</div>
</div><!-- fragment --><p>To be specific, putting the <code>typename...</code> last is a requirement for class templates, but for function templates, parameter packs can appear anywhere.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Processing parameter pack elements with recursive templates</h1>
<p>In the ideal case the developer will not have to process the individual elements of a parameter pack, because the <code>as...</code> variable will resolve to the actual arguments that the compiler can understand.</p>
<p>However, sometimes you run into situations where the template itself needs to process through the arguments in a parameter pack. A common pattern to deal with parameter pack iteration is to write templates so they process one argument at a time in a recursive fashion. As a reminder, recursion is a programming technique where a function calls itself instead of using a loop construct: </p><div class="fragment"><div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">// sum_vector recursively calls itself</div>
<div class="line">int sum_vector(int cur, std::vector&lt;int&gt;::iterator it, std::vector&lt;int&gt;::iterator end) {</div>
<div class="line">    if(it != end) {</div>
<div class="line">        return sum_vector(sum + *it, ++it, end);</div>
<div class="line">    } else {</div>
<div class="line">        return cur;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; v{1,5,17,3};</div>
<div class="line">    std::cout &lt;&lt; sum_vector(0, v.begin(), v.end()) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">26</div>
<div class="line">$</div>
</div><!-- fragment --><p>Variadic template arguments are often processed in a similar fashion, handling one concrete argument at a time. They break out of recursion by writing an overloaded template or function with the same function name that does not recursively call itself: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">// final function when no arguments are left to process</div>
<div class="line">void print() { </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// handle one argument at a time</div>
<div class="line">template &lt;typename A, typename... As&gt;</div>
<div class="line">void print(A&amp;&amp; a, As&amp;&amp;... as) {</div>
<div class="line">    std::cout &lt;&lt; std::forward&lt;A&gt;(a); // process one argument</div>
<div class="line">    print(std::forward&lt;As&gt;(as)...); // pass the rest to another print call</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    print(&quot;hello&quot;, &quot; &quot;, &quot;world&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">hello world</div>
<div class="line">$</div>
</div><!-- fragment --><p>The compiler actually writes a function definition to handle every generated usage of a template. The naive generated code from the above templates might look something like: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">void print() {</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void print(const char* a) {</div>
<div class="line">    std::cout &lt;&lt; a;</div>
<div class="line">    print();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void print(const char* a, const char* b) {</div>
<div class="line">    std::cout &lt;&lt; a;</div>
<div class="line">    print(b);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void print(const char* a, const char* b, const char* c) {</div>
<div class="line">    std::cout &lt;&lt; a;</div>
<div class="line">    print(b, c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    print(&quot;hello&quot;, &quot; &quot;, &quot;world&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, in reality the compiler will probably inline much of the above to be something more like: </p><div class="fragment"><div class="line">include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; &quot;hello&quot;;</div>
<div class="line">    std::cout &lt;&lt; &quot; &quot;;</div>
<div class="line">    std::cout &lt;&lt; &quot;world&quot;;</div>
<div class="line">    std::cout &lt;&lt; endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md41"></a>
Callables and parameter packs</h1>
<p>Callables can be easily combined with parameter packs to pass arbitrary number of arguments to them: </p><div class="fragment"><div class="line">#include &lt;string&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename F, typename... As&gt; // declare a template parameter pack </div>
<div class="line">auto // allow the compiler to deduce the return type </div>
<div class="line">execute_callable_with_args(F&amp;&amp; f, As&amp;&amp;... as) {</div>
<div class="line">    return f(std::forward&lt;As&gt;(as)...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int foo() {</div>
<div class="line">    return 3;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int faa(int i, int i2, int i3) {</div>
<div class="line">    return i + i2 + i3;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct s {</div>
<div class="line">    std::string operator()(std::string s, std::string s2) {</div>
<div class="line">        return s + s2;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::cout &lt;&lt; execute_callable_with_args(foo) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable_with_args(faa, 1, 2, 3) &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; execute_callable_with_args(s(), &quot;hello&quot;, &quot; world&quot;) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">3</div>
<div class="line">6</div>
<div class="line">hello world</div>
<div class="line">$</div>
</div><!-- fragment --><p>The above pattern allows for very flexible algorithm construction.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
Iterator group advancement</h1>
<p>One pattern that is useful in advanced algorithms is the ability to iterate over multiple containers simultaneously. This can be done simply via parameter packs and recursive template calls (which will be trivially inlined): </p><div class="fragment"><div class="line">// explicitly accept iterators as references</div>
<div class="line">template &lt;typename IT&gt;</div>
<div class="line">void advance_group(IT&amp; it) { // process the final iterator</div>
<div class="line">    ++it; // advance the iterator by reference</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;typename IT, typename IT2, typename... ITs&gt;</div>
<div class="line">void advance_group(IT&amp; it, IT2&amp; it2, ITs&amp;... its) {</div>
<div class="line">    ++it; // advance the iterator by reference</div>
<div class="line">    advance_group(it2, its...); // advance the remaining iterators</div>
<div class="line">}</div>
</div><!-- fragment --><p>This allows for the creation of algorithms which execute a Callable on any number of container elements: </p><div class="fragment"><div class="line">namespace detail {</div>
<div class="line"> </div>
<div class="line">template &lt;typename F, typename IT, typename... ITs&gt;</div>
<div class="line">void each(F&amp;&amp; f, IT&amp;&amp; it, IT&amp;&amp; it_end, ITs&amp;&amp;... its) {</div>
<div class="line">    while(it != it_end) { // while we haven&#39;t reached the end of the current container</div>
<div class="line">        f(*it, *its...); // f is executed with the current element in each container</div>
<div class="line">        advance_group(it, its...); // advance the iterators</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>We can use another template to abstract the usage of iterators: </p><div class="fragment"><div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">// include our detail::each </div>
<div class="line"> </div>
<div class="line">template &lt;typename F, typename C, typename... Cs&gt;</div>
<div class="line">void</div>
<div class="line">each(F&amp;&amp; f, C&amp;&amp; c, Cs&amp;&amp;... cs) {</div>
<div class="line">    detail::each(f, c.begin(), c.end(), cs.begin()...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; v1{1,2,3};</div>
<div class="line">    std::vector&lt;int&gt; v2{4,5,6};</div>
<div class="line">    std::vector&lt;int&gt; out;</div>
<div class="line"> </div>
<div class="line">    auto add = [&amp;out](int a, int b){ out.push_back(a + b); };</div>
<div class="line">    each(add, v1, v2);</div>
<div class="line"> </div>
<div class="line">    for(auto&amp; e : out) {</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">5</div>
<div class="line">7</div>
<div class="line">9</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md43"></a>
Thunks and Callbacks</h1>
<p>One common usecase for template code is implementing callbacks. A callback is a Callable which is executed when an event occurs. The classic example of a callback is executing a function when a state machine processes an event and executes a some event "on entry" function. However the "event" which triggers a callback can be anything, even implicit events, like a Callable being at the front of queue of other callbacks waiting to execute on a worker thread. Another callback usecase is a timer, where a function is executed after a certain amount of time has elapsed.</p>
<p>But how do we write callback functions? Classically this was done with function pointers and an associated <code>void*</code> data pointer. To keep things simple, lets look at a theoretical worker thread queue which can have functions and data registered for execution on it. In some worker queue header: </p><div class="fragment"><div class="line">struct worker_thread_t { </div>
<div class="line">    // ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void init_worker_thread(worker_thread_t* worker);</div>
<div class="line">void launch_worker_thread(worker_thread_t* worker);</div>
<div class="line">void shutdown_worker_thread(worker_thread_t* worker);</div>
<div class="line">void schedule_work(worker_thread_t* worker, void(*callback)(void*), void* data);</div>
</div><!-- fragment --><p>Then in some user code: </p><div class="fragment"><div class="line">#include &lt;string.h&gt;</div>
<div class="line">#include &lt;stdio.h&gt;</div>
<div class="line">#include &quot;worker_thread.h&quot;</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">void print_something(void* data) {</div>
<div class="line">    printf(&quot;%s\n&quot;,(const char*)data);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int retval = 0;</div>
<div class="line">    // ...</div>
<div class="line">    worker_thread_t my_worker;</div>
<div class="line">    init_worker_thread(&amp;my_worker);</div>
<div class="line">    launch_worker_thread(&amp;my_worker);</div>
<div class="line">    // ...</div>
<div class="line">    schedule_work(&amp;my_worker, print_something, &quot;hello world!&quot;);</div>
<div class="line">    // ...</div>
<div class="line">    shutdown_worker_thread(&amp;my_worker);</div>
<div class="line">    // ...</div>
<div class="line">    return retval;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this might look something like: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">// ... potentially other things printed ...</div>
<div class="line">hello world!</div>
<div class="line">// ... potentially other things printed ...</div>
<div class="line">$</div>
</div><!-- fragment --><p>You could do something similar with <code>c++</code> Functors which implement some base type that a worker object understands: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;worker_thread.hpp&quot;</div>
<div class="line"> </div>
<div class="line">struct worker_thread { </div>
<div class="line">    // ...</div>
<div class="line">    struct callback {</div>
<div class="line">        virtual ~callback() { };</div>
<div class="line">        virtual void execute() = 0;</div>
<div class="line">    };</div>
<div class="line">    // ...</div>
<div class="line">    worker_thread();</div>
<div class="line">    void launch();</div>
<div class="line">    void shutdown();</div>
<div class="line">    void schedule_work(callback* cb);</div>
<div class="line">    // ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct user_callback : public worker_thread::callback {</div>
<div class="line">    virtual void execute() {</div>
<div class="line">        // ...</div>
<div class="line">        std::cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; std::endl;</div>
<div class="line">        // ...</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// ... </div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int retval = 0;</div>
<div class="line">    // ...</div>
<div class="line">    worker_thread wt;</div>
<div class="line">    wt.launch();</div>
<div class="line">    // ...</div>
<div class="line">    wt.schedule_work(new user_callback);</div>
<div class="line">    // ...</div>
<div class="line">    wt.shutdown();</div>
<div class="line">    // ...</div>
<div class="line">    return retval;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The output of such a function would be similar to the previous. Both of these techniques are clunky, they require lots of boilerplate and nothing is too convenient about them other than the fact that they <em>work</em>. But can templates help us make something better? Behold the noble <code>c++</code> thunk: </p><div class="fragment"><div class="line">typedef std::function&lt;void()&gt; thunk;</div>
</div><!-- fragment --><p>A <a href="https://stackoverflow.com/questions/2641489/what-is-a-thunk">thunk</a> is conceptually just a function (or Functor) that when called does something, although its purpose is abstracted from the calling code. They typically don't return anything (unless the user is implementing a <a href="https://en.wikipedia.org/wiki/Trampoline_(computing)">trampoline</a>). <code>std::function&lt;void()&gt;</code> is capable of holding any callable and therefore is an excellent replacement for both function pointer/void* data pairs and Functor inheritance.</p>
<p>However, with templates we can do even better, we can convert <em>any</em> Callable into a thunk using templated lambda captures: </p><div class="fragment"><div class="line">template &lt;typename F, typename... As&gt;</div>
<div class="line">thunk to_thunk(F&amp;&amp; f, As&amp;&amp;... as) {</div>
<div class="line">    return [=]() mutable { f(std::forward&lt;As&gt;(as)...); };</div>
<div class="line">}</div>
</div><!-- fragment --><p>If we rewrite out worker thread with this in mind we can achieve great things: </p><div class="fragment"><div class="line">struct worker_thread { </div>
<div class="line">    typedef std::function&lt;void()&gt; thunk;</div>
<div class="line"> </div>
<div class="line">    // ...</div>
<div class="line">    worker_thread();</div>
<div class="line">    void launch();</div>
<div class="line">    void shutdown();</div>
<div class="line">    void schedule_work(thunk);</div>
<div class="line"> </div>
<div class="line">    // wrap non-thunks as a thunk</div>
<div class="line">    template &lt;typename F, typename... As&gt;</div>
<div class="line">    void schedule_work(F&amp;&amp; f, As&amp;&amp;... as) {</div>
<div class="line">        schedule_work(thunk([=]() mutable { f(std::forward&lt;As&gt;(as)...); }));</div>
<div class="line">    }</div>
<div class="line">    // ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now we are free to wildly execute callbacks with great abandon: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;worker_thread.hpp&quot;</div>
<div class="line"> </div>
<div class="line">void print_something(const char* s) {</div>
<div class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">struct my_functor {</div>
<div class="line">    void operator()(const char* s) {</div>
<div class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    int retval = 0;</div>
<div class="line">    // ...</div>
<div class="line">    worker_thread wt;</div>
<div class="line">    wt.launch();</div>
<div class="line">    // ...</div>
<div class="line">    wt.schedule_work(print_something, &quot;this is print_something!&quot;);</div>
<div class="line">    wt.schedule_work(my_functor(), &quot;this is my_functor!&quot;);</div>
<div class="line">    wt.schedule_work([](const char* s) { std::cout &lt;&lt; s &lt;&lt; std::endl; }, &quot;this is my lambda!&quot;);</div>
<div class="line">    // ...</div>
<div class="line">    wt.shutdown();</div>
<div class="line">    // ...</div>
<div class="line">    return retval;</div>
<div class="line">}</div>
</div><!-- fragment --><p>You of course get: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">// ... potentially other output ...</div>
<div class="line">this is print_something!</div>
<div class="line">this is my_functor!</div>
<div class="line">this is my lambda!</div>
<div class="line">// ... potentially other output ...</div>
<div class="line">$</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
