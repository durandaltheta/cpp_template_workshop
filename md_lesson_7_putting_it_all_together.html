<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: Putting it All Together</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Putting it All Together </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md49"></a>
What now?</h1>
<p>The techniques covered in the previous lessons are all I'm going to explicitly teach in this course, they are already a pretty good foundation. There are many minor sub-features of templates, many helper structs and functions in the standard library, and many composite techniques which build on the essentials. All of these are nice but they don't matter until you explicitly need them, and they can be discovered as necessary when you need them.</p>
<p>What's more important now is to consider the question: <em>how</em> should I write <em>my</em> templates?</p>
<h1><a class="anchor" id="autotoc_md50"></a>
Keep it simple stupid</h1>
<p>In my opinion, good templates are not about what's possible, they are about what's helpful. Therefore, you should <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">follow the principle of least surprise</a>.</p>
<p>A programmer using your templates has very many things they need to do in their day, learning the ins and outs of your particular flavor of template library code doesn't need to be one of them. In almost every case, a developer's most pressing concern is getting their code working correctly, not forming the perfect algorithm.</p>
<p>API is the most important aspect of template code, because it is the part that has to interface with the knowledge of the user. If the API is kept simple and understandable, users will be both more willing to use your code and more likely to use it correctly.</p>
<p>When attempting to address a problem with a template consider these factors:</p><ul>
<li>Could my API be made more similar to other API that the user likely understands which solves similar problems?</li>
<li>Do the names of objects and functions clearly describe what they do?</li>
<li>Are the names of objects and functions no longer than necessary?</li>
<li>Can my overall design be simplified without omitting necessary functionality?</li>
</ul>
<p>Think back to the <code>init_thread</code> example in the README.md: </p><div class="fragment"><div class="line">template &lt;typename InitFunction, typename Function, typename... OptionalArgs&gt;</div>
<div class="line">std::thread init_thread(InitFunction&amp;&amp; init_f, Function&amp;&amp; f, OptionalArgs&amp;&amp;... args) {</div>
<div class="line">    // figure out the scary synchronization once</div>
<div class="line">    std::mutex mtx;</div>
<div class="line">    std::condition_variable cv;</div>
<div class="line">    bool flag = false;</div>
<div class="line"> </div>
<div class="line">    std::thread thd([=, &amp;mtx, &amp;cv, &amp;flag]() mutable {</div>
<div class="line">        // do thread initialization</div>
<div class="line">        init_f();</div>
<div class="line"> </div>
<div class="line">        // notify parent thread initialization is complete</div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lk(mtx);</div>
<div class="line">            flag = true;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        cv.notify_one();</div>
<div class="line"> </div>
<div class="line">        // proceed with regular thread operation</div>
<div class="line">        f(std::forward&lt;OptionalArgs&gt;(args)...);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    // wait for thread initialization</div>
<div class="line">    {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lk(mtx);</div>
<div class="line"> </div>
<div class="line">        while(!flag) {</div>
<div class="line">            cv.wait(lk);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // don&#39;t need to move local variable, compiler will use copy elision </div>
<div class="line">    // https://en.cppreference.com/w/cpp/language/copy_elision</div>
<div class="line">    return thd; </div>
<div class="line">}</div>
</div><!-- fragment --><p>With regards to the above questions:</p><ul>
<li>The API is intentionally similar to <code>std::thread::thread()</code> to make it easier to grasp</li>
<li>The name <code>init_thread</code> gives a rough idea of what the function is capable of</li>
<li>The name <code>init_thread</code> and types <code>InitFunction</code>, <code>Function</code>, <code>OptionalArgs</code> succinctly describe their purpose</li>
<li>The overall design only adds one new argument above <code>std::thread::thread()</code>, it would be difficult to simplify it further</li>
</ul>
<h1><a class="anchor" id="autotoc_md51"></a>
The clockwork internals</h1>
<p>With all that said about simplicity of API, my experience has simultaneously shown that the <em>internals</em> of template code can as complicated as necessary in order to better solve problems. As long as the API is thoroughly tested, the user doesn't have to learn <em>how</em> it works, only be confident it <em>will</em> work.</p>
<p>This doesn't mean that complexity should be blindly accepted within template internals, as over-complexity may be a sign of bad design. Only, the template author shouldn't feel inhibited by adding complexity where it is warranted.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
Expanding on the foundations of the language</h1>
<p>Templates allow the creation of new <code>c++</code> language features that may be entirely outside of the design scope of the base language and standard library. While not always necessary or desirable, in some cases it may be worth considering using new ideas.</p>
<p>For example, in the Rust programming language, they have a different philosophy of how mutexes work. The <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">rust std::sync::Mutex object</a> is both a value and a lower level mutex. In order to read or write to the stored value, the user must first lock the <code>std::sync::Mutex</code> object which returns another object that contains the (Rust equivalent to a) reference to the value. This design eleminates an entire class of issues arising from accessing shared values because it forces users to correctly lock their data while also helping to scope the lifetime of that lock.</p>
<p>With templates, implementing a similar lock in <code>c++</code> is very possible. While considering some of the naming in the standard library for similar objects like <code>std::unique_lock</code> and <code>std::lock_guard</code>, our lock might look like: </p><div class="fragment"><div class="line">#include &lt;mutex&gt;</div>
<div class="line"> </div>
<div class="line">template &lt;typename T, typename MUTEX = std::mutex&gt;</div>
<div class="line">struct value_guard {</div>
<div class="line">    // extend `std::unique_lock`</div>
<div class="line">    struct unique_lock : public std::unique_lock&lt;MUTEX&gt; {</div>
<div class="line">        unique_lock(std::unique_lock&lt;MUTEX&gt;&amp;&amp; lk, T&amp; t) : </div>
<div class="line">            std::unique_lock&lt;MUTEX&gt;(std::move(lk)), // call parent std::unique_lock&lt;MUTEX&gt; constructor</div>
<div class="line">            value(t) // assign reference to value T</div>
<div class="line">        { }</div>
<div class="line"> </div>
<div class="line">        T&amp; value; // reference to value T</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    // intialize value T during constructor</div>
<div class="line">    template &lt;typename... As&gt;</div>
<div class="line">    value_guard(As&amp;&amp;... as) : </div>
<div class="line">        m_t(std::forward&lt;As&gt;(as)...)</div>
<div class="line">    { }</div>
<div class="line"> </div>
<div class="line">    // Acquire a locked unique_lock containing a reference to stored value T.</div>
<div class="line">    inline value_guard::unique_lock acquire() {</div>
<div class="line">        return unique_lock{std::unique_lock&lt;MUTEX&gt;(m_mtx), m_t};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    T m_t;</div>
<div class="line">    MUTEX m_mtx;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This design combines the necessity of atomically protecting shared data, with the high level features of <code>c++</code> synchronization mechanisms. For instance, because <code>value_guard::unique_lock</code> inherits from <code>std::unique_lock</code>, you should be able to use it with <code>std::condition_variable</code>, even if it requires casting.</p>
<p>Usage of the above might look something like this in a trivial case: </p><div class="fragment"><div class="line">// ...</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;value_guard_header.hpp&quot;</div>
<div class="line">// ...</div>
<div class="line">value_guard&lt;int&gt; g_shared_value;</div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">void user_thread_func() {</div>
<div class="line">    // ... </div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        auto lk = g_shared_value.acquire();</div>
<div class="line"> </div>
<div class="line">        // can interact safely with value</div>
<div class="line">        std::cout &lt;&lt; lk.value &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // lk goes out of scope releasing the underlying std::mutex</div>
<div class="line"> </div>
<div class="line">    // ... </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // ...</div>
<div class="line"> </div>
<div class="line">    std::thread user_thread(user_thread_func);</div>
<div class="line"> </div>
<div class="line">    // ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>All of this illustrates the point that templates expand what is possible in <code>c++</code>, potentially improving your code. Therefore, if a feature in a different language seems useful in your <code>c++</code> library or project, it may be worth considering how efficiently the concept could be ported.</p>
<h1><a class="anchor" id="autotoc_md53"></a>
Further examples of well designed API</h1>
<p>I'm a fan of the <a href="https://www.scheme.com/tspl4/">scheme</a> functional programming language. <code>scheme</code> is a <code>LISP</code> variant with a focus on efficient, minimal API. It is also one of those languages (alongside <code>LISP</code> variants more generally) which incorporate very flexible data processing algorithms. These algorithms consistently find their way in some form into other high level programming languages. In fact many of the most powerful features that pop up in other languages were pioneered in the <code>LISP</code> family of programming languages. These include:</p><ul>
<li>generics, templates, and macros</li>
<li>closures (lambda captures)</li>
<li>coroutines (built from continuations)</li>
</ul>
<p>It should also be noted that <code>scheme</code> primarily operates on linked lists instead of arrays or vectors, and their algorithms are normally written against said lists. A short list of some of the most <code>scheme</code> important algorithms:</p><ul>
<li><a href="https://www.scheme.com/tspl4/control.html#./control:s30">map</a>: apply a function to elements of one or more lists, returning the results in a list</li>
<li><a href="https://www.scheme.com/tspl4/control.html#./control:s33">for-each</a>: similar to <code>map</code> but does not return a list of values.</li>
<li><a href="https://www.scheme.com/tspl4/control.html#./control:s38">fold-left</a>: perform a calculation on one or more lists by evaluating it with a function with an init value, evaluating from left to right</li>
<li><a href="https://www.scheme.com/tspl4/control.html#./control:s36">exists</a>: apply a function to elements of one or more lists until function returns <code>true</code>, causing <code>exists</code> to return <code>true</code>. If function never returns <code>true</code>, <code>exists</code> returns <code>false</code></li>
<li><a href="https://www.scheme.com/tspl4/control.html#./control:s37">for-all</a>: apply a function to elements of one or more lists, until function returns <code>false</code>, causing <code>for-all</code> to return <code>false</code>. If function never returns <code>false</code>, <code>for-all</code> returns <code>true</code>.</li>
</ul>
<p>The above functions are extremely flexible, as well as frequently <a href="https://en.wikipedia.org/wiki/Composability">composable</a>. It's actually astounding the number of other algorithms that can be generated using only those above. For this very reason, I have provided implementations of each of these in <a href="inc/scalgorithm.hpp">scalgorithm header</a> for both the education and utility of the reader. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
