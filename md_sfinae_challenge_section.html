<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: SFINAE CHALLENGE SECTION - method detection</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">SFINAE CHALLENGE SECTION - method detection </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A very advanced usage of SFINAE can occur when trying to write template specializations which are selected based on whether a templated type has a necessary method.</p>
<p>The following information is not required to complete the course, however it is extremely useful as a measuring stick for a developer's ability to understand SFINAE in action.</p>
<p>The example I am about to show is <a href="https://en.cppreference.com/w/cpp/language/constraints">potentially no longer required as of c++20 using constraints</a>, but again, is useful for understanding SFINAE.</p>
<p>YOU WILL PROBABLY HAVE TO READ THIS SEVERAL TIMES (AND PRACTICE IN BETWEEN) TO FULLY UNDERSTAND. YOU HAVE BEEN WARNED.</p>
<p>Here is the complete code for determining if a given object <code>T</code> has the method <code>size()</code>: </p><div class="fragment"><div class="line">// put this in a sub-namespace because it should not be used directly by usercode</div>
<div class="line">namespace detail { </div>
<div class="line"> </div>
<div class="line">template&lt;typename T&gt;</div>
<div class="line">struct has_size {</div>
<div class="line">    template&lt;typename U, typename U::size_type (U::*)() const&gt; struct SFINAE {};</div>
<div class="line">    template&lt;typename U&gt; static char test(SFINAE&lt;U, &amp;U::size&gt;*);</div>
<div class="line">    template&lt;typename U&gt; static int test(...);</div>
<div class="line">    static const bool has = sizeof(test&lt;T&gt;(0)) == sizeof(char);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Almost all <code>std</code> containers have the method <code>size()</code>, but not all. Example: <code>std::forward_list&lt;T&gt;</code>. Since, it might be nice (or necessary) to be able to write an edgecase which can handle containers without the <code>size()</code> method we can use the above struct to do detect when the edgecase needs to be selected.</p>
<p>This code abuses compile time constants. Essentially, if a variable is <code>const</code> or a function is a <code>constexpr</code> then the compiler must be able to know its value <em>during</em> compilation. The c++ standard allows values known at compile time to be used inside of template declarations (IE, within the <code>&lt; &gt;</code> brackets) and other places. In practice, this means we can write limited <code>if/else</code> logic to determine <em>which</em> template gets used at certain times.</p>
<p>I will go through this struct line by line to explain everything that's going on:</p>
<div class="fragment"><div class="line">template&lt;typename T&gt;</div>
<div class="line">struct has_size {</div>
</div><!-- fragment --><p>We are defining a placeholder struct named <code>has_size&lt;T&gt;</code>. We need this struct because we need to use SFINAE to determine if type <code>T</code> has a method named <code>size()</code> which returns an unsigned number.</p>
<div class="fragment"><div class="line">template&lt;typename U, typename U::size_type (U::*)() const&gt; struct SFINAE {};</div>
</div><!-- fragment --><p>We are declaring a template struct <em>inside</em> of the template struct <code>has_size</code> with potentially a different type <code>U</code> because we don't want the compiler to try to produce the final code <em>yet</em>. Instead, we want to wait to make the final code once the compiler has figured out what type of container <code>U</code> we are dealing with.</p>
<p>The code <code>U::size_type</code> is specifying that whatever <code>U</code> is <em>must</em> have some type defined called <code>size_type</code>. Every <code>std</code> container defines this type. <code>size_type</code> is always some number type, typically an unsigned integer.</p>
<p>The code <code>U::size_type (U::*)() const</code> is a function pointer. The <code>U::*</code> is the template mechanism for specifying "function pointer in the `U` namespace". Function pointers typically look like: <code>return_type (*)(arg_1_type, arg_2_type, etc...)</code>. See <a href="https://en.cppreference.com/w/cpp/language/pointer">cppreference's pointer section, subsection "Pointers to functions"</a> for a basic primer on function pointers.</p>
<p>In this case, we are specifying that for our struct <code>SFINAE</code> to be valid, <code>U</code> must have some const method (a class function which will not modify member variables) which has no arguments and returns a <code>U::size_type</code>. That is, we're really looking for if <code>U</code> has a function <code>size_type size() const</code>, and we are identifying if it has at least one member function which matches that pattern.</p>
<div class="fragment"><div class="line">template&lt;typename U&gt; static char test(SFINAE&lt;U, &amp;U::size&gt;*);</div>
</div><!-- fragment --><p>This is a forward declaration of a template method belonging to <code>has_size</code>. As the name of this method implies, we are using it to test something, in this case we are testing <em>at compilation time</em> (not runtime!) if we can create a valid <code>SFINAE</code> object based on the characteristics of the object we are checking a <code>size()</code> function for.</p>
<p>This <code>SFINAE</code> object must be able to declare a function pointer to a method <code>U::size</code> as its second template argument. If this template succeeds, this test will be selected and <code>has_size</code> will have a method named <code>test</code> which returns a <code>char</code>. If this is the case, then we know type <code>U</code> has a method <code>size()</code>!</p>
<div class="fragment"><div class="line">template&lt;typename U&gt; static int test(...);</div>
</div><!-- fragment --><p>This is a forward declaration of a template method as a fallback in case the previous test template cannot produce valid code (in which case <code>T</code> does <em>NOT</em> have a <code>size()</code> method!).</p>
<div class="fragment"><div class="line">static const bool has = sizeof(test&lt;T&gt;(0)) == sizeof(char);</div>
</div><!-- fragment --><p><code>has</code> is created by comparing <em>theoretical</em> return value type sizes. Essentially <em>IF</em> the method <code>test&lt;T&gt;</code> was called (remember, <code>T</code> is the type of <code>has_size</code>, the object we checking for a <code>size()</code> method), then <code>sizeof()</code> can determine the byte size of <code>test&lt;T&gt;</code>'s return value.</p>
<p>Our first <code>test()</code> template returns a <code>char</code>, while the second returns an <code>int</code>, which are guaranteed by the c++ standard to be of <em>different byte sizes</em>.</p>
<p>If <code>test()</code> returns a <code>char</code>, then <code>T</code> has the function <code>size()</code>. Otherwise if <code>test()</code> returns an <code>int</code>, then <code>T</code> does <em>NOT</em> have the function <code>size()</code>.</p>
<p>This means we are assigning a value of <code>true</code> to <code>has</code> if the first <code>test&lt;T&gt;</code> is selected (meaning type <code>T</code> has a method <code>size()</code>!), otherwise we are assigning <code>false</code>.</p>
<p>To use the <code>has_size</code> <code>struct</code>, we will need a couple more functions: </p><div class="fragment"><div class="line">namespace detail {</div>
<div class="line"> </div>
<div class="line">// Get the size of an object with its `size()` method</div>
<div class="line">template &lt;typename C&gt;</div>
<div class="line">size_t size(C&amp; c, std::true_type) { </div>
<div class="line">    return c.size(); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Get the size of an object the *slow* way by iterating through it</div>
<div class="line">template &lt;typename C&gt;</div>
<div class="line">size_t size(C&amp; c, std::false_type) {</div>
<div class="line">    return std::distance(c.begin(), c.end());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Above I have defined the two function overloads we can call to return the size of a container. The first simply calls <code>C::size()</code>, while the second iterates through the container <code>C</code> and increments a count. They accept special empty objects <code>std::true_type</code> and <code>std::false_type</code>, two different types that can be returned by some <code>c++</code> standard library template utility functions.</p>
<p>Finally, to make the compiler choose one the two implementations, we wrap the call to <code>detail::size()</code> in another function: </p><div class="fragment"><div class="line">template &lt;typename C&gt;</div>
<div class="line">size_t // size_t is convertable from all std:: container `size_type`s</div>
<div class="line">size(C&amp;&amp; c) { </div>
<div class="line">    return detail::size(c, std::integral_constant&lt;bool, detail::has_size&lt;C&gt;::has&gt;()); </div>
<div class="line">}</div>
</div><!-- fragment --><p>When our <code>size()</code> function is called with an argument type <code>C</code>, it selects the proper <code>detail::size()</code> implementation based on the result of the compile time expression <code>std::integral_constant&lt;bool, detail::has_size&lt;C&gt;::has&gt;()</code>.</p>
<p><code>std::integral_constant&lt;T,T2&gt;</code> is a <code>c++</code> helper struct which has a <code>constexpr</code> method <code>std::integral_constant&lt;T,T2&gt;::operator()()</code> which returns either a <code>std::true_type</code> if the types <code>T</code> and <code>T2</code> are identical or <code>std::false_type</code> otherwise.</p>
<p>Since said method <code>std::integral_constant&lt;T,T2&gt;::operator()()</code> is a <code>constexpr</code>, the compiler <em>always</em> knows what this return type will be during compilation, allowing us select one of the two implementations of <code>detail::size()</code>:</p>
<p>If <code>std::true_type</code> (object has a <code>size()</code> method): </p><div class="fragment"><div class="line">template &lt;typename C&gt;</div>
<div class="line">size_t size(C&amp; c, std::true_type);</div>
</div><!-- fragment --><p>Otherwise <code>std::false_type</code> (object has no <code>size()</code> method): </p><div class="fragment"><div class="line">template &lt;typename C&gt;</div>
<div class="line">size_t size(C&amp; c, std::false_type);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
