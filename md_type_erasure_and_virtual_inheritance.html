<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple C++ Algorithms: type erasure using virtual inheritance</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simple C++ Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">type erasure using virtual inheritance </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Another mechanism to implement type erasure is through the usage of interface classes. The <code>virtual</code> keyword is used to denote a method in a <code>class</code> (or <code>struct</code>, which are also <code>class</code>es under the hood) which can be "overwritten" at runtime by a child <code>class</code> which implements their own version of them. Under the hood, the compiler is using function pointers to determine what <em>actual</em> function to call: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">struct interface {</div>
<div class="line">    virtual void foo() {</div>
<div class="line">        std::cout &lt;&lt; &quot;foo&quot; &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct child : public interface {</div>
<div class="line">    virtual void foo() { // overwrite the interface implementation</div>
<div class="line">        std::cout &lt;&lt; &quot;faa&quot; &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    child c;</div>
<div class="line">    c.foo();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">faa</div>
<div class="line">$</div>
</div><!-- fragment --><p>Additionally, if a <code>virtual</code> method declaration is post-pended with a <code>= 0;</code> then that method is called a "pure virtual" method. A pure virtual method makes the <code>class</code> "abstract". An abstract <code>class</code> is what is known as an "interface" in other programming languages, essentially a specification of required methods that an inheriting class <em>must</em> implement. If a class does not implement every pure virtual method it inherits, the child class is <em>also</em> an abstract class.</p>
<p>An abstract <code>class</code> cannot be created directly, but it can be inherited. If the child <code>class</code> fully implements the missing "pure virtual" methods of the abstract class then the child <code>class</code> <em>can</em> be constructed. </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">struct interface {</div>
<div class="line">    virtual void foo() = 0; // no implementation in a pure virtual function</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct child : public interface {</div>
<div class="line">    virtual void foo() { // implements the pure virtual interface method</div>
<div class="line">        std::cout &lt;&lt; &quot;faa&quot; &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    child c;</div>
<div class="line">    c.foo();</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">faa</div>
<div class="line">$</div>
</div><!-- fragment --><p>One of the advantages of <code>virtual</code> methods and interfaces is that references/pointers to a class which implements the base class/interface can be <a href="https://en.cppreference.com/w/cpp/language/dynamic_cast">dynamic_cast</a> to a reference/pointer of the base class/interface. This casting process is often done implicitly by the compiler, although it can be done explicitly when necessary. When the methods of the cast base class reference/pointer are called, the child classes methods will <em>actually</em> be called instead: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">struct interface {</div>
<div class="line">    virtual void foo() = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">struct child : public interface {</div>
<div class="line">    virtual void foo() { </div>
<div class="line">        std::cout &lt;&lt; &quot;faa&quot; &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">void call_foo(interface&amp; i) {</div>
<div class="line">    i.foo();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    child c;</div>
<div class="line">    call_foo(c); // implicitly dynamically cast by the compiler to `interface`</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">faa</div>
<div class="line">$</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md73"></a>
Combining virtual inheritance with type erasure</h1>
<p>Combining all of the above with <code>void*</code> type erasure and templating allows for some very interesting code. Here is an example of how type erasure could be implemented using virtual inheritance in an object which can accept any type by-value: </p><div class="fragment"><div class="line">#include &lt;type_info&gt;</div>
<div class="line">#include &lt;type_traits&gt;</div>
<div class="line">#include &lt;memory&gt;</div>
<div class="line">#include &lt;exception&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">// pure virtual interface class</div>
<div class="line">struct any_interface {</div>
<div class="line">    virtual void* data() = 0;</div>
<div class="line">    virtual const std::type_info* type() = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// templated implementation of the interface class</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">struct any_impl : public any_interface {</div>
<div class="line">    template &lt;typename T&gt;</div>
<div class="line">    any_impl(T&amp;&amp; t) : m_t(std::forward&lt;T&gt;(t)) { }</div>
<div class="line"> </div>
<div class="line">    // interface implementations</div>
<div class="line">    virtual void* data() { return (void*)&amp;m_t; }</div>
<div class="line">    virtual const std::type_info* type() { return m_type; }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    T m_t;</div>
<div class="line">    const std::type_info* m_type = &amp;(typeid(T));</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// exception to throw when user casts to an invalid type</div>
<div class="line">struct bad_any_cast : public std::exception {</div>
<div class="line">    const char* what() const noexcept {</div>
<div class="line">        return &quot;the cast type is incorrect you dummy!&quot;;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// wrapper object which can be constructed with any type</div>
<div class="line">struct any {</div>
<div class="line">    // create specific constructors when assigning from another any object</div>
<div class="line">    any(const any&amp; rhs) : m_any_int(rhs.m_any_int) { }</div>
<div class="line">    any(any&amp; rhs) : m_any_int(rhs.m_any_int) { }</div>
<div class="line">    any(any&amp;&amp; rhs) : m_any_int(rhs.m_any_int) { }</div>
<div class="line"> </div>
<div class="line">    // template constructor for assignment from some value T</div>
<div class="line">    template &lt;typename T&gt;</div>
<div class="line">    any(T&amp;&amp; t) : </div>
<div class="line">        m_any_int(allocate(std::forward&lt;T&gt;(t)) )</div>
<div class="line">    { }</div>
<div class="line"> </div>
<div class="line">    // can implement assignment operators in a similar fashion to the constructors </div>
<div class="line">    // ...</div>
<div class="line">    </div>
<div class="line">    // return `true` if this object contains a value, else `false`</div>
<div class="line">    operator bool() {</div>
<div class="line">        return m_any_int; // calls `std::shared_ptr&lt;any_interface&gt;::operator bool()`</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    template &lt;typename T&gt;</div>
<div class="line">    any_interface* allocate(T&amp;&amp; t) {</div>
<div class="line">        return new any_impl&lt;std::decay_t&lt;T&gt;&gt;(std::forward&lt;T&gt;(t));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;any_interface&gt; m_any_int;</div>
<div class="line"> </div>
<div class="line">    // allow friend function to access private members</div>
<div class="line">    friend template &lt;typename T&gt; T any_cast(any&amp;);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// method to extract a value or reference of type T from an any object</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">T any_cast(any&amp; a) {</div>
<div class="line">    typedef std::decay_t&lt;T&gt; DT;</div>
<div class="line"> </div>
<div class="line">    if(a &amp;&amp; *(a.m_any_int-&gt;type()) != typeid(DT)) {</div>
<div class="line">        throw bad_any_cast();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return *((DT*)(m_any_int-&gt;data()));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    any a(std::string(&quot;faa&quot;));</div>
<div class="line">    std::cout &lt;&lt; any_cast&lt;std::string&gt;(a) &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Executing this program: </p><div class="fragment"><div class="line">$ ./a.out </div>
<div class="line">faa</div>
<div class="line">$</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
