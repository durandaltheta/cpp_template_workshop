<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple thread: sca Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simple thread
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sca Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsca_1_1slice__of.html">slice_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the underlying type returned by <code><a class="el" href="namespacesca.html#a22ebd5fb06cb77ea976ccd58cf828b3b" title="create a slice_of object from a container which allows iteration over a subset of another container">slice()</a></code> representing a subset of a container  <a href="classsca_1_1slice__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsca_1_1const__slice__of.html">const_slice_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const variation of <a class="el" href="classsca_1_1slice__of.html" title="the underlying type returned by slice() representing a subset of a container">slice_of</a>  <a href="classsca_1_1const__slice__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a30d7b247d1fcd4364bbc20018617f9a6"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a30d7b247d1fcd4364bbc20018617f9a6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#a30d7b247d1fcd4364bbc20018617f9a6">size</a> (C &amp;&amp;c)</td></tr>
<tr class="memdesc:a30d7b247d1fcd4364bbc20018617f9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an iterable container's size, regardless if it implements a <code><a class="el" href="namespacesca.html#a30d7b247d1fcd4364bbc20018617f9a6" title="return an iterable container&#39;s size, regardless if it implements a size() method">size()</a></code> method  <a href="namespacesca.html#a30d7b247d1fcd4364bbc20018617f9a6">More...</a><br /></td></tr>
<tr class="separator:a30d7b247d1fcd4364bbc20018617f9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd8691329735fab9b04cc0b1c174995"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:adbd8691329735fab9b04cc0b1c174995"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#adbd8691329735fab9b04cc0b1c174995">pointers</a> (C &amp;c)</td></tr>
<tr class="memdesc:adbd8691329735fab9b04cc0b1c174995"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy the addresses of elements in a container to a new container  <a href="namespacesca.html#adbd8691329735fab9b04cc0b1c174995">More...</a><br /></td></tr>
<tr class="separator:adbd8691329735fab9b04cc0b1c174995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7178678ad4f448b12e701f05ed6c14af"><td class="memTemplParams" colspan="2"><a id="a7178678ad4f448b12e701f05ed6c14af"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a7178678ad4f448b12e701f05ed6c14af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pointers</b> (const C &amp;c)</td></tr>
<tr class="separator:a7178678ad4f448b12e701f05ed6c14af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0fee0ba6ceec37d72f741961d6c74a"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aba0fee0ba6ceec37d72f741961d6c74a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#aba0fee0ba6ceec37d72f741961d6c74a">values</a> (C &amp;&amp;c)</td></tr>
<tr class="memdesc:aba0fee0ba6ceec37d72f741961d6c74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a container of deep value copies (never pointers) from a container of values or pointers  <a href="namespacesca.html#aba0fee0ba6ceec37d72f741961d6c74a">More...</a><br /></td></tr>
<tr class="separator:aba0fee0ba6ceec37d72f741961d6c74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ebd5fb06cb77ea976ccd58cf828b3b"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a22ebd5fb06cb77ea976ccd58cf828b3b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#a22ebd5fb06cb77ea976ccd58cf828b3b">slice</a> (C &amp;&amp;c, size_t idx, size_t len)</td></tr>
<tr class="memdesc:a22ebd5fb06cb77ea976ccd58cf828b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a <code><a class="el" href="classsca_1_1slice__of.html" title="the underlying type returned by slice() representing a subset of a container">slice_of</a></code> object from a container which allows iteration over a subset of another container  <a href="namespacesca.html#a22ebd5fb06cb77ea976ccd58cf828b3b">More...</a><br /></td></tr>
<tr class="separator:a22ebd5fb06cb77ea976ccd58cf828b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d417b2153711672fa03fda0efdfa0b8"><td class="memTemplParams" colspan="2"><a id="a5d417b2153711672fa03fda0efdfa0b8"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a5d417b2153711672fa03fda0efdfa0b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slice</b> (const C &amp;c, size_t idx, size_t len)</td></tr>
<tr class="separator:a5d417b2153711672fa03fda0efdfa0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5f19dad022bedb6a8ef77f7132e19b"><td class="memTemplParams" colspan="2"><a id="a7b5f19dad022bedb6a8ef77f7132e19b"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a7b5f19dad022bedb6a8ef77f7132e19b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>slice</b> (C &amp;c, size_t idx, size_t len)</td></tr>
<tr class="separator:a7b5f19dad022bedb6a8ef77f7132e19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaf5368bbfc8ee0a3b061879c3cdede"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:abdaf5368bbfc8ee0a3b061879c3cdede"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#abdaf5368bbfc8ee0a3b061879c3cdede">mslice</a> (C &amp;&amp;c, size_t idx, size_t len)</td></tr>
<tr class="memdesc:abdaf5368bbfc8ee0a3b061879c3cdede"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a mutable <code><a class="el" href="classsca_1_1slice__of.html" title="the underlying type returned by slice() representing a subset of a container">slice_of</a></code> object which allows iteration of a subset of another container  <a href="namespacesca.html#abdaf5368bbfc8ee0a3b061879c3cdede">More...</a><br /></td></tr>
<tr class="separator:abdaf5368bbfc8ee0a3b061879c3cdede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2543e0a45cabb925c3d37e7211d51b20"><td class="memTemplParams" colspan="2"><a id="a2543e0a45cabb925c3d37e7211d51b20"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:a2543e0a45cabb925c3d37e7211d51b20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mslice</b> (C &amp;c, size_t idx, size_t len)</td></tr>
<tr class="separator:a2543e0a45cabb925c3d37e7211d51b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aba454e0a9c35992fe5fc76cc86d0b"><td class="memTemplParams" colspan="2">template&lt;typename C , typename C2 , typename... Cs&gt; </td></tr>
<tr class="memitem:ac3aba454e0a9c35992fe5fc76cc86d0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#ac3aba454e0a9c35992fe5fc76cc86d0b">group</a> (C &amp;&amp;c, C2 &amp;&amp;c2, Cs &amp;&amp;... cs)</td></tr>
<tr class="memdesc:ac3aba454e0a9c35992fe5fc76cc86d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">assemble a container containing all elements of two or more containers  <a href="namespacesca.html#ac3aba454e0a9c35992fe5fc76cc86d0b">More...</a><br /></td></tr>
<tr class="separator:ac3aba454e0a9c35992fe5fc76cc86d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df3b99676249c848f745b9d1e0c42d1"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a3df3b99676249c848f745b9d1e0c42d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#a3df3b99676249c848f745b9d1e0c42d1">reverse</a> (C &amp;&amp;c)</td></tr>
<tr class="memdesc:a3df3b99676249c848f745b9d1e0c42d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a container where the order of elements is the reverse of the input container  <a href="namespacesca.html#a3df3b99676249c848f745b9d1e0c42d1">More...</a><br /></td></tr>
<tr class="separator:a3df3b99676249c848f745b9d1e0c42d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51d8227d350b7ace5217c3b4562b869"><td class="memTemplParams" colspan="2">template&lt;typename C , typename F &gt; </td></tr>
<tr class="memitem:ac51d8227d350b7ace5217c3b4562b869"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#ac51d8227d350b7ace5217c3b4562b869">sort</a> (C &amp;&amp;c, F &amp;&amp;cmp)</td></tr>
<tr class="memdesc:ac51d8227d350b7ace5217c3b4562b869"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a container whose elements are sorted based on a comparison Callable  <a href="namespacesca.html#ac51d8227d350b7ace5217c3b4562b869">More...</a><br /></td></tr>
<tr class="separator:ac51d8227d350b7ace5217c3b4562b869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc0c64ff0323a97d4a2381d1a084de5"><td class="memTemplParams" colspan="2">template&lt;typename F , typename C &gt; </td></tr>
<tr class="memitem:a0fc0c64ff0323a97d4a2381d1a084de5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#a0fc0c64ff0323a97d4a2381d1a084de5">filter</a> (F &amp;&amp;f, C &amp;&amp;c)</td></tr>
<tr class="memdesc:a0fc0c64ff0323a97d4a2381d1a084de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a filtered container of elements  <a href="namespacesca.html#a0fc0c64ff0323a97d4a2381d1a084de5">More...</a><br /></td></tr>
<tr class="separator:a0fc0c64ff0323a97d4a2381d1a084de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7645a0d8ab845f91e58bbf858bc759c8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename C , typename... Cs&gt; </td></tr>
<tr class="memitem:a7645a0d8ab845f91e58bbf858bc759c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#a7645a0d8ab845f91e58bbf858bc759c8">map</a> (F &amp;&amp;f, C &amp;&amp;c, Cs &amp;&amp;... cs)</td></tr>
<tr class="memdesc:a7645a0d8ab845f91e58bbf858bc759c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate function with the elements of containers grouped by index and return a container filled with the results of each function call  <a href="namespacesca.html#a7645a0d8ab845f91e58bbf858bc759c8">More...</a><br /></td></tr>
<tr class="separator:a7645a0d8ab845f91e58bbf858bc759c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437e669af61265f87419693670bee063"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Result , typename C , typename... Cs&gt; </td></tr>
<tr class="memitem:a437e669af61265f87419693670bee063"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#a437e669af61265f87419693670bee063">fold</a> (F &amp;&amp;f, Result &amp;&amp;init, C &amp;&amp;c, Cs &amp;&amp;... cs)</td></tr>
<tr class="memdesc:a437e669af61265f87419693670bee063"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a calculation on the elements of containers grouped by index  <a href="namespacesca.html#a437e669af61265f87419693670bee063">More...</a><br /></td></tr>
<tr class="separator:a437e669af61265f87419693670bee063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db3037dd0db498cab5eee408d419827"><td class="memTemplParams" colspan="2">template&lt;typename F , typename C , typename... Cs&gt; </td></tr>
<tr class="memitem:a9db3037dd0db498cab5eee408d419827"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#a9db3037dd0db498cab5eee408d419827">each</a> (F &amp;&amp;f, C &amp;&amp;c, Cs &amp;&amp;... cs)</td></tr>
<tr class="memdesc:a9db3037dd0db498cab5eee408d419827"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate function with the elements of containers grouped by index  <a href="namespacesca.html#a9db3037dd0db498cab5eee408d419827">More...</a><br /></td></tr>
<tr class="separator:a9db3037dd0db498cab5eee408d419827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a6d7b3cb2a51977177ae6d15ae7b4b"><td class="memTemplParams" colspan="2">template&lt;typename F , typename C , typename... Cs&gt; </td></tr>
<tr class="memitem:ac2a6d7b3cb2a51977177ae6d15ae7b4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#ac2a6d7b3cb2a51977177ae6d15ae7b4b">all</a> (F &amp;&amp;f, C &amp;&amp;c, Cs &amp;&amp;... cs)</td></tr>
<tr class="memdesc:ac2a6d7b3cb2a51977177ae6d15ae7b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate if a function returns <code>true</code> with all the elements of containers grouped by index  <a href="namespacesca.html#ac2a6d7b3cb2a51977177ae6d15ae7b4b">More...</a><br /></td></tr>
<tr class="separator:ac2a6d7b3cb2a51977177ae6d15ae7b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcfb883c20eadaed8da521efdac6d34"><td class="memTemplParams" colspan="2">template&lt;typename F , typename C , typename... Cs&gt; </td></tr>
<tr class="memitem:addcfb883c20eadaed8da521efdac6d34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesca.html#addcfb883c20eadaed8da521efdac6d34">some</a> (F &amp;&amp;f, C &amp;&amp;c, Cs &amp;&amp;... cs)</td></tr>
<tr class="memdesc:addcfb883c20eadaed8da521efdac6d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate if a function returns <code>true</code> with at least one of the elements of containers grouped by index  <a href="namespacesca.html#addcfb883c20eadaed8da521efdac6d34">More...</a><br /></td></tr>
<tr class="separator:addcfb883c20eadaed8da521efdac6d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A NOTE ON API DESIGN As a note, much of the complexity of these templates is caused by more effort being put into usability for the user, rather than implementing minimalist algorithms.</p>
<p>The algorithms defined in the c++ standard library typically deal with iterators rather than the containers themselves. Instead, this library's data processing algorithms accept containers as arguments and return containers, because this leaves the smallest amount of work for the user and reduces risk of exception throwing bugs. This also helps the user avoid making trivial efficiency mistakes when writing algorithm code.</p>
<p>In c++, vectors typically outperform other container types, so algorithms in this library convert to them internally and return them as the result.</p>
<p>PROVIDED ALGORITHMS The algorithms in this header library are intended for general usecases and composability (the results of one algorithm can often be used as an argument in another). They are not exhaustive, but should cover the majority of simple data processing usecases.</p>
<p>Algorithms and Objects provided by this header: <a class="el" href="namespacesca.html#a30d7b247d1fcd4364bbc20018617f9a6" title="return an iterable container&#39;s size, regardless if it implements a size() method">size()</a> - return an iterable container's size, regardless if it implements a <code><a class="el" href="namespacesca.html#a30d7b247d1fcd4364bbc20018617f9a6" title="return an iterable container&#39;s size, regardless if it implements a size() method">size()</a></code> method <a class="el" href="namespacesca.html#adbd8691329735fab9b04cc0b1c174995" title="copy the addresses of elements in a container to a new container">pointers()</a> - return container of the addresses of elements in another container <a class="el" href="namespacesca.html#aba0fee0ba6ceec37d72f741961d6c74a" title="return a container of deep value copies (never pointers) from a container of values or pointers">values()</a> - return a container of deep value copies (never pointers) from a container of values or pointers <a class="el" href="namespacesca.html#a22ebd5fb06cb77ea976ccd58cf828b3b" title="create a slice_of object from a container which allows iteration over a subset of another container">slice()</a> - return a (potentially const) object capable of iterating a subset of a container <a class="el" href="namespacesca.html#abdaf5368bbfc8ee0a3b061879c3cdede" title="create a mutable slice_of object which allows iteration of a subset of another container">mslice()</a> - return an object capable of iterating a mutable subset of a container <a class="el" href="namespacesca.html#ac3aba454e0a9c35992fe5fc76cc86d0b" title="assemble a container containing all elements of two or more containers">group()</a> - return a container composed of all elements of all argument containers <a class="el" href="namespacesca.html#a3df3b99676249c848f745b9d1e0c42d1" title="return a container where the order of elements is the reverse of the input container">reverse()</a> - return a container whose elements are in reverse order of input container <a class="el" href="namespacesca.html#ac51d8227d350b7ace5217c3b4562b869" title="return a container whose elements are sorted based on a comparison Callable">sort()</a> = return a container whose elements are sorted based on a comparison Callable <a class="el" href="namespacesca.html#a0fc0c64ff0323a97d4a2381d1a084de5" title="return a filtered container of elements">filter()</a> - return a container filled with only elements which return true when applied to a Callable <a class="el" href="namespacesca.html#a7645a0d8ab845f91e58bbf858bc759c8" title="evaluate function with the elements of containers grouped by index and return a container filled with...">map()</a> - return the results of applying all elements of argument containers to a Callable <a class="el" href="namespacesca.html#a437e669af61265f87419693670bee063" title="perform a calculation on the elements of containers grouped by index">fold()</a> - calculate a result after iterating through all elements of argument containers <a class="el" href="namespacesca.html#a9db3037dd0db498cab5eee408d419827" title="evaluate function with the elements of containers grouped by index">each()</a> - apply a Callable to every element of a container <a class="el" href="namespacesca.html#ac2a6d7b3cb2a51977177ae6d15ae7b4b" title="evaluate if a function returns true with all the elements of containers grouped by index">all()</a> - return true if all elements return true when applied to a Callable <a class="el" href="namespacesca.html#addcfb883c20eadaed8da521efdac6d34" title="evaluate if a function returns true with at least one of the elements of containers grouped by index">some()</a> - return true if at least one element returns true when applied to a Callable </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac2a6d7b3cb2a51977177ae6d15ae7b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a6d7b3cb2a51977177ae6d15ae7b4b">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename C , typename... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sca::all </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate if a function returns <code>true</code> with all the elements of containers grouped by index </p>
<p>Evaluation ends when traversible element in container c has been iterated.</p>
<p>Each container can contain a different value type as long as the value type can be passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a predicate function applied to elements of input containers </td></tr>
    <tr><td class="paramname">c</td><td>the first container whose elements will have f applied to </td></tr>
    <tr><td class="paramname">cs</td><td>the optional remaining containers whose elements will have f applied to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>f</code> returns <code>true</code> for all iterated elements, else <code>false</code> </dd></dl>

</div>
</div>
<a id="a9db3037dd0db498cab5eee408d419827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db3037dd0db498cab5eee408d419827">&#9670;&nbsp;</a></span>each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename C , typename... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sca::each </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate function with the elements of containers grouped by index </p>
<p>Evaluation ends when traversible element in container c has been iterated.</p>
<p>No value is returned from this function, any changes are side effects of executing the function.</p>
<p>Each container can contain a different value type as long as the value type can be passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a function to call </td></tr>
    <tr><td class="paramname">c</td><td>the first container </td></tr>
    <tr><td class="paramname">cs...</td><td>the remaining containers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc0c64ff0323a97d4a2381d1a084de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc0c64ff0323a97d4a2381d1a084de5">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::filter </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a filtered container of elements </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a predicate function which gets applied to each element of the input container </td></tr>
    <tr><td class="paramname">c</td><td>the input container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container of only the elements for which applying the predicate returned <code>true</code> </dd></dl>

</div>
</div>
<a id="a437e669af61265f87419693670bee063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437e669af61265f87419693670bee063">&#9670;&nbsp;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Result , typename C , typename... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::fold </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a calculation on the elements of containers grouped by index </p>
<p>Evaluation ends when traversible element in container c has been iterated.</p>
<p>The argument function must accept the current value as its first argument, and the elements of the argument containers stored in the current index. The value returned by the function becomes the new current value. When all indices have been processed <code><a class="el" href="namespacesca.html#a437e669af61265f87419693670bee063" title="perform a calculation on the elements of containers grouped by index">fold()</a></code> will return the final return value of the function.</p>
<p>Each container can contain a different value type as long as the value type can be passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the calculation function </td></tr>
    <tr><td class="paramname">init</td><td>the initial value of the calculation being performed </td></tr>
    <tr><td class="paramname">c</td><td>the first container whose elements will be calculated </td></tr>
    <tr><td class="paramname">cs</td><td>optional additional containers whose elements will also be calculated one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final calculated value returned from function f </dd></dl>

</div>
</div>
<a id="ac3aba454e0a9c35992fe5fc76cc86d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aba454e0a9c35992fe5fc76cc86d0b">&#9670;&nbsp;</a></span>group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename C2 , typename... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::group </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assemble a container containing all elements of two or more containers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the first container whose elements should be grouped together with the others </td></tr>
    <tr><td class="paramname">c2</td><td>the second container whose elements should be grouped together with the others </td></tr>
    <tr><td class="paramname">cs</td><td>optional, additional containers whose elements should be grouped together with the others </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container containing all elements of the arguments </dd></dl>

</div>
</div>
<a id="a7645a0d8ab845f91e58bbf858bc759c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7645a0d8ab845f91e58bbf858bc759c8">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename C , typename... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::map </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate function with the elements of containers grouped by index and return a container filled with the results of each function call </p>
<p>Evaluation begins at index 0, and ends when every traversible element in container c has been iterated. It returns an <code>std::vector&lt;T&gt;</code> (where <code>T</code> is the deduced return value of user function <code>f</code>) containing the result of every invocation of user function <code>f</code>.</p>
<p>Each container can contain a different value type as long as the value type can be passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a function to call </td></tr>
    <tr><td class="paramname">c</td><td>the first container </td></tr>
    <tr><td class="paramname">cs...</td><td>the remaining containers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container R of the results from calling f with elements in c and cs... </dd></dl>

</div>
</div>
<a id="abdaf5368bbfc8ee0a3b061879c3cdede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdaf5368bbfc8ee0a3b061879c3cdede">&#9670;&nbsp;</a></span>mslice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::mslice </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a mutable <code><a class="el" href="classsca_1_1slice__of.html" title="the underlying type returned by slice() representing a subset of a container">slice_of</a></code> object which allows iteration of a subset of another container </p>
<p>This is the mutable reference implementation of the algorithm, returning a <code><a class="el" href="classsca_1_1slice__of.html" title="the underlying type returned by slice() representing a subset of a container">slice_of</a></code>. This can be dangerous when used inline carelessly, as it will be treated as an rvalue by algorithms causing unexpected swaps. Best usage is to explicitly save the result of this method as an lvalue before usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> my_lvalue_slice = <a class="code" href="namespacesca.html#abdaf5368bbfc8ee0a3b061879c3cdede">sca::mslice</a>(my_container, 0, 13);</div>
<div class="line"><span class="keyword">auto</span> my_result = <a class="code" href="namespacesca.html#a7645a0d8ab845f91e58bbf858bc759c8">sca::map</a>(my_function, my_lvalue_slice));</div>
<div class="ttc" id="anamespacesca_html_a7645a0d8ab845f91e58bbf858bc759c8"><div class="ttname"><a href="namespacesca.html#a7645a0d8ab845f91e58bbf858bc759c8">sca::map</a></div><div class="ttdeci">auto map(F &amp;&amp;f, C &amp;&amp;c, Cs &amp;&amp;... cs)</div><div class="ttdoc">evaluate function with the elements of containers grouped by index and return a container filled with...</div><div class="ttdef"><b>Definition:</b> scalgorithm.hpp:634</div></div>
<div class="ttc" id="anamespacesca_html_abdaf5368bbfc8ee0a3b061879c3cdede"><div class="ttname"><a href="namespacesca.html#abdaf5368bbfc8ee0a3b061879c3cdede">sca::mslice</a></div><div class="ttdeci">auto mslice(C &amp;&amp;c, size_t idx, size_t len)</div><div class="ttdoc">create a mutable slice_of object which allows iteration of a subset of another container</div><div class="ttdef"><b>Definition:</b> scalgorithm.hpp:522</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>starting index of the range of values </td></tr>
    <tr><td class="paramname">len</td><td>ending index of the range of values </td></tr>
    <tr><td class="paramname">c</td><td>container to take slice of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a slice object capable of iterating a given container </dd></dl>

</div>
</div>
<a id="adbd8691329735fab9b04cc0b1c174995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd8691329735fab9b04cc0b1c174995">&#9670;&nbsp;</a></span>pointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::pointers </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy the addresses of elements in a container to a new container </p>
<p>This a helper mechanism for ensuring all calculations on data are by reference to a specific set of values. This can be used to simplify operations on large sets of data so that downstream calculations like <code><a class="el" href="namespacesca.html#a0fc0c64ff0323a97d4a2381d1a084de5" title="return a filtered container of elements">filter()</a></code> and <code><a class="el" href="namespacesca.html#a7645a0d8ab845f91e58bbf858bc759c8" title="evaluate function with the elements of containers grouped by index and return a container filled with...">map()</a></code> never have to consider reference value categories.</p>
<p>This algorithm also useful when sorting data in-place without modifying the source data's container positions (std::sort()), while still being able to reference the original data within the sorted set. Furthermore, any kind of sort operation when applied to pointers is very fast.</p>
<p>It may be beneficial to apply <code><a class="el" href="namespacesca.html#adbd8691329735fab9b04cc0b1c174995" title="copy the addresses of elements in a container to a new container">pointers()</a></code> to the result of <code><a class="el" href="namespacesca.html#a22ebd5fb06cb77ea976ccd58cf828b3b" title="create a slice_of object from a container which allows iteration over a subset of another container">slice()</a></code>, to only operate on the necessary subset of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>container of elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container of pointers to elements in the argument container </dd></dl>

</div>
</div>
<a id="a3df3b99676249c848f745b9d1e0c42d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df3b99676249c848f745b9d1e0c42d1">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::reverse </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a container where the order of elements is the reverse of the input container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>an input container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new container with elements reversed from the input container </dd></dl>

</div>
</div>
<a id="a30d7b247d1fcd4364bbc20018617f9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d7b247d1fcd4364bbc20018617f9a6">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t sca::size </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return an iterable container's size, regardless if it implements a <code><a class="el" href="namespacesca.html#a30d7b247d1fcd4364bbc20018617f9a6" title="return an iterable container&#39;s size, regardless if it implements a size() method">size()</a></code> method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the container </dd></dl>

</div>
</div>
<a id="a22ebd5fb06cb77ea976ccd58cf828b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ebd5fb06cb77ea976ccd58cf828b3b">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::slice </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a <code><a class="el" href="classsca_1_1slice__of.html" title="the underlying type returned by slice() representing a subset of a container">slice_of</a></code> object from a container which allows iteration over a subset of another container </p>
<p>This implementation only gets selected when the input container is an rvalue. The <code><a class="el" href="classsca_1_1slice__of.html" title="the underlying type returned by slice() representing a subset of a container">slice_of</a></code> object will keep the original container in memory as long as the <code><a class="el" href="classsca_1_1slice__of.html" title="the underlying type returned by slice() representing a subset of a container">slice_of</a></code> object exists.</p>
<p>Typical usecase is to use <code>auto</code> as the returned variable's type: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> my_slice = <a class="code" href="namespacesca.html#a22ebd5fb06cb77ea976ccd58cf828b3b">sca::slice</a>(my_container, 0, 13);</div>
<div class="line"><span class="keyword">auto</span> my_result = <a class="code" href="namespacesca.html#a7645a0d8ab845f91e58bbf858bc759c8">sca::map</a>(my_function, my_slice);</div>
<div class="ttc" id="anamespacesca_html_a22ebd5fb06cb77ea976ccd58cf828b3b"><div class="ttname"><a href="namespacesca.html#a22ebd5fb06cb77ea976ccd58cf828b3b">sca::slice</a></div><div class="ttdeci">auto slice(C &amp;&amp;c, size_t idx, size_t len)</div><div class="ttdoc">create a slice_of object from a container which allows iteration over a subset of another container</div><div class="ttdef"><b>Definition:</b> scalgorithm.hpp:486</div></div>
</div><!-- fragment --><p>Or to use the slice inline: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> my_result = <a class="code" href="namespacesca.html#a7645a0d8ab845f91e58bbf858bc759c8">sca::map</a>(my_function, <a class="code" href="namespacesca.html#a22ebd5fb06cb77ea976ccd58cf828b3b">sca::slice</a>(my_container, 0, 13));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>starting index of the range of values </td></tr>
    <tr><td class="paramname">len</td><td>ending index of the range of values </td></tr>
    <tr><td class="paramname">c</td><td>container to take slice of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a slice object capable of iterating a given container </dd></dl>

</div>
</div>
<a id="addcfb883c20eadaed8da521efdac6d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcfb883c20eadaed8da521efdac6d34">&#9670;&nbsp;</a></span>some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename C , typename... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sca::some </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate if a function returns <code>true</code> with at least one of the elements of containers grouped by index </p>
<p>Evaluation ends when traversible element in container c has been iterated.</p>
<p>Each container can contain a different value type as long as the value type can be passed to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a predicate function applied to elements of input containers </td></tr>
    <tr><td class="paramname">c</td><td>the first container whose elements will have f applied to </td></tr>
    <tr><td class="paramname">cs</td><td>the optional remaining containers whose elements will have f applied to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>f</code> returns <code>true</code> for at least one iterated element, else <code>false</code> </dd></dl>

</div>
</div>
<a id="ac51d8227d350b7ace5217c3b4562b869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51d8227d350b7ace5217c3b4562b869">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::sort </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a container whose elements are sorted based on a comparison Callable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>container whose elements will be copied and sorted in the output </td></tr>
    <tr><td class="paramname">cmp</td><td>a function which must accept two elements from the container and return a boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sorted container of elements </dd></dl>

</div>
</div>
<a id="aba0fee0ba6ceec37d72f741961d6c74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0fee0ba6ceec37d72f741961d6c74a">&#9670;&nbsp;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sca::values </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a container of deep value copies (never pointers) from a container of values or pointers </p>
<p>If input argument is a container of pointers, those pointers are dereferenced before copying.</p>
<p>Useful when operations on the result of a call to <code><a class="el" href="namespacesca.html#adbd8691329735fab9b04cc0b1c174995" title="copy the addresses of elements in a container to a new container">sca::pointers()</a></code> are complete and a copy of pointed values is required. It is also useful when copying an arbitrary container or slice into a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a container of values or pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container of value copies </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
